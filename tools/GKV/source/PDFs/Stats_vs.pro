FUNCTION GKVs2D::Stats_vs, arg, _EXTRA=extra;;	Purpose:;; 			Returns a structure containing statistics of 'self';			as a GKVs1D objects as a function of the the indicated ;			independent variable.  ;; 	Argument:;;			The (optional) argument is any legal axis identifier.;			That is, either an integer between 1 and nDims, or;			a STRING containing an axis mnemonic.;;	Keywords:;;	   Axis		If no argument is provided, then this keyword may be ;			used to identify independent variable. Set axis ;			equal to any legal axis identifier (see above).;;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the independent variable, and to ;			reset the signal window on this axis (before computing the statistics).;			This two-element array is interpreted as the desired RANGE in;			the independent variable, NOT the integer 'irange';;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window before computing the statistics w.r.t. the selected independent variable.;;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable over which the statists ;			are to be computed.;;	Side Effects:;;			If a 'range' or 'irange' is specified on the command line ;			(either directly, or via 'mnemonic' = ...) then the ;			SignalWindow method will be invoked on 'self' and,;			on return, the signal window of the selected independent;			variable will have been modified.;;; Written by W.M. Nevins;	4/26/02;; Find axis identifier;FORWARD_FUNCTION GKVsd_MINCASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	else	:	BEGIN				MESSAGE, 'Stats_vs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIFresult = self -> MakeCopy()result -> restrictaxisString = STRING(axis, FORMAT='(I1)')commandString = 'Grid = result.Grid' + axisStringok = EXECUTE(commandString)resultValuePtr = result -> GetValues(/Open)values = *resultValuePtrPTR_FREE, resultValuePtrinfo = SIZE(values)type=info[info[0]+1]npoints = info[axis]irange = Grid.irangeimin = irange[0]imax = irange[1]moments = MAKE_ARRAY(4,npoints, TYPE=type)CASE axis OF	1	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[i,*])			END	2	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,i])			ENDENDCASE;; Now load statistics in 'moments' into output objects; mean = {GKVs1D}nTags = N_TAGS({GKVsd})FOR i=0,nTags-1 DO mean.(i)=self.(i)mean.mnemonic='Avg_' + self.mnemonicmean.title = '!12<!X' + self.title + '!12>!X'indices = ['*']mean.indices = PTR_NEW(indices)mean.units = self.unitsmean.values = PTR_NEW(REFORM(moments[0,*]))vmin = GKVsd_MIN(moments[0,*], MAX=vmax)mean.vrange = [vmin, vmax]mean.ErrorBars = PTR_NEW()mean.Grid1 = GKVsd_GridCopy(grid)meanObj = OBJ_NEW('GKVs1D', mean)std = meanstd.mnemonic = 'STD_' + self.mnemonicstd.title = '!4r!X{' + self.title + '}'std.units = self.unitsstd.values = PTR_NEW(SQRT(REFORM(moments[1,*])))vmin = GKVsd_MIN(SQRT(REFORM(moments[1,*])), MAX=vmax)std.vrange = [vmin, vmax]std.Grid1 = GKVsd_GridCopy(grid)stdObj = OBJ_NEW('GKVs1D', std)variance = stdvariance.mnemonic = 'Var_' + self.mnemonicvariance.title = '!4r!X!U2!N{' + self.title + '}'variance.units = '(' + self.units + ')!U2!N'variance.values = PTR_NEW(REFORM(moments[1,*]))vmin = GKVsd_MIN(REFORM(moments[1,*]), MAX=vmax)variance.vrange = [vmin, vmax]variance.Grid1 = GKVsd_GridCopy(grid)varianceObj = OBJ_NEW('GKVs1D', variance)skewness = varianceskewness.mnemonic = 'Skew_' + self.mnemonicskewness.title = '!4c!X!D1!N{' + self.title + '}'skewness.units = ''skewness.values = PTR_NEW(REFORM(moments[2,*]))vmin = GKVsd_MIN(moments[2,*], MAX=vmax)skewness.vrange = [vmin, vmax]skewness.Grid1 = GKVsd_GridCopy(grid)skewnessObj = OBJ_NEW('GKVs1D', skewness)kurtosis = skewnesskurtosis.mnemonic = 'Kur_' + self.mnemonickurtosis.title =  '!4c!X!D2!N{' + self.title + '}'kurtosis.units = ''kurtosis.values = PTR_NEW(REFORM(moments[3,*]))vmin = GKVsd_MIN(moments[3,*], MAX=vmax)kurtosis.vrange = [vmin, vmax]kurtosis.Grid1 = GKVsd_GridCopy(grid)kurtosisObj = OBJ_NEW('GKVs1D', kurtosis);; Prepare output structure;name = 'Stats_' + self.mnemonicresult -> trashresult = {Name:name, mean:meanObj, std:stdObj, variance:varianceObj, skewness:skewnessObj, kurtosis:kurtosisObj};; and we're done ...;RETURN, resultEND ; ****** GKVs2D::Stats_vs ****** ;FUNCTION GKVs3D::Stats_vs, arg, _EXTRA=extra;;	Purpose:;; 			Returns a structure containing statistics of 'self';			as a GKVs1D objects as a function of the the indicated ;			independent variable.  ;; 	Argument:;;			The (optional) argument is any legal axis identifier.;			That is, either an integer between 1 and nDims, or;			a STRING containing an axis mnemonic.;;	Keywords:;;	   Axis		If no argument is provided, then this keyword may be ;			used to identify independent variable. Set axis ;			equal to any legal axis identifier (see above).;;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the independent variable, and to ;			reset the signal window on this axis (before computing the statistics).;			This two-element array is interpreted as the desired RANGE in;			the independent variable, NOT the integer 'irange';;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window before computing the statistics w.r.t. the selected independent variable.;;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable over which the statists ;			are to be computed.;;	Side Effects:;;			If a 'range' or 'irange' is specified on the command line ;			(either directly, or via 'mnemonic' = ...) then the ;			SignalWindow method will be invoked on 'self' and,;			on return, the signal window of the selected independent;			variable will have been modified.;;; Written by W.M. Nevins;	4/26/02;; Find axis identifier;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	else	:	BEGIN				MESSAGE, 'Stats_vs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIFresult = self -> MakeCopy()result -> restrictaxisString = STRING(axis, FORMAT='(I1)')commandString = 'Grid = result.Grid' + axisStringok = EXECUTE(commandString)resultValuePtr = result -> GetValues(/Open)values = *resultValuePtrPTR_FREE, resultValuePtrinfo = SIZE(values)type=info[info[0]+1]npoints = info[axis]irange = Grid.irangeimin = irange[0]imax = irange[1]moments = MAKE_ARRAY(4,npoints, TYPE=type)CASE axis OF	1	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[i,*,*])			END	2	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,i,*])			END	3	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,*,i])			ENDENDCASE;; Now load statistics in 'moments' into output objects; mean = {GKVs1D}nTags = N_TAGS({GKVsd})FOR i=0,nTags-1 DO mean.(i)=self.(i)mean.mnemonic='Avg_' + self.mnemonicmean.title = '!12<!X' + self.title + '!12>!X'indices = ['*']mean.indices = PTR_NEW(indices)mean.units = self.unitsmean.values = PTR_NEW(REFORM(moments[0,*]))vmin = GKVsd_MIN(moments[0,*], MAX=vmax)mean.vrange = [vmin, vmax]mean.ErrorBars = PTR_NEW()mean.Grid1 = GKVsd_GridCopy(grid)meanObj = OBJ_NEW('GKVs1D', mean)std = meanstd.mnemonic = 'STD_' + self.mnemonicstd.title = '!4r!X{' + self.title + '}'std.units = self.unitsstd.values = PTR_NEW(SQRT(REFORM(moments[1,*])))vmin = GKVsd_MIN(SQRT(REFORM(moments[1,*])), MAX=vmax)std.vrange = [vmin, vmax]std.Grid1 = GKVsd_GridCopy(grid)stdObj = OBJ_NEW('GKVs1D', std)variance = stdvariance.mnemonic = 'Var_' + self.mnemonicvariance.title = '!4r!X!U2!N{' + self.title + '}'variance.units = '(' + self.units + ')!U2!N'variance.values = PTR_NEW(REFORM(moments[1,*]))vmin = GKVsd_MIN(REFORM(moments[1,*]), MAX=vmax)variance.vrange = [vmin, vmax]variance.Grid1 = GKVsd_GridCopy(grid)varianceObj = OBJ_NEW('GKVs1D', variance)skewness = varianceskewness.mnemonic = 'Skew_' + self.mnemonicskewness.title = '!4c!X!D1!N{' + self.title + '}'skewness.units = ''skewness.values = PTR_NEW(REFORM(moments[2,*]))vmin = GKVsd_MIN(moments[2,*], MAX=vmax)skewness.vrange = [vmin, vmax]skewness.Grid1 = GKVsd_GridCopy(grid)skewnessObj = OBJ_NEW('GKVs1D', skewness)kurtosis = skewnesskurtosis.mnemonic = 'Kur_' + self.mnemonickurtosis.title =  '!4c!X!D2!N{' + self.title + '}'kurtosis.units = ''kurtosis.values = PTR_NEW(REFORM(moments[3,*]))vmin = GKVsd_MIN(moments[3,*], MAX=vmax)kurtosis.vrange = [vmin, vmax]kurtosis.Grid1 = GKVsd_GridCopy(grid)kurtosisObj = OBJ_NEW('GKVs1D', kurtosis);; Prepare output structure;name = 'Stats_' + self.mnemonicresult -> trashresult = {Name:name, mean:meanObj, std:stdObj, variance:varianceObj, skewness:skewnessObj, kurtosis:kurtosisObj};; and we're done ...;RETURN, resultEND ; ****** GKVs3D::Stats_vs ****** ;FUNCTION GKVs4D::Stats_vs, arg, _EXTRA=extra;;	Purpose:;; 			Returns a structure containing statistics of 'self';			as a GKVs1D objects as a function of the the indicated ;			independent variable.  ;; 	Argument:;;			The (optional) argument is any legal axis identifier.;			That is, either an integer between 1 and nDims, or;			a STRING containing an axis mnemonic.;;	Keywords:;;	   Axis		If no argument is provided, then this keyword may be ;			used to identify independent variable. Set axis ;			equal to any legal axis identifier (see above).;;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the independent variable, and to ;			reset the signal window on this axis (before computing the statistics).;			This two-element array is interpreted as the desired RANGE in;			the independent variable, NOT the integer 'irange';;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window before computing the statistics w.r.t. the selected independent variable.;;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable over which the statists ;			are to be computed.;;	Side Effects:;;			If a 'range' or 'irange' is specified on the command line ;			(either directly, or via 'mnemonic' = ...) then the ;			SignalWindow method will be invoked on 'self' and,;			on return, the signal window of the selected independent;			variable will have been modified.;;; Written by W.M. Nevins;	4/26/02;; Find axis identifier;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	else	:	BEGIN				MESSAGE, 'Stats_vs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIFresult = self -> MakeCopy()result -> restrictaxisString = STRING(axis, FORMAT='(I1)')commandString = 'Grid = result.Grid' + axisStringok = EXECUTE(commandString)resultValuePtr = result -> GetValues(/Open)values = *resultValuePtrPTR_FREE, resultValuePtrinfo = SIZE(values)type=info[info[0]+1]npoints = info[axis]irange = Grid.irangeimin = irange[0]imax = irange[1]moments = MAKE_ARRAY(4,npoints, TYPE=type)CASE axis OF	1	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[i,*,*,*])			END	2	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,i,*,*])			END	3	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,*,i,*])			END	4	:	Begin		FOR i=imin, imax DO moments[*,i] = MOMENT(values[*,*,*,i])			ENDENDCASE;; Now load statistics in 'moments' into output objects; mean = {GKVs1D}nTags = N_TAGS({GKVsd})FOR i=0,nTags-1 DO mean.(i)=self.(i)mean.mnemonic='Avg_' + self.mnemonicmean.title = '!12<!X' + self.title + '!12>!X'indices = ['*']mean.indices = PTR_NEW(indices)mean.units = self.unitsmean.values = PTR_NEW(REFORM(moments[0,*]))vmin = GKVsd_MIN(moments[0,*], MAX=vmax)mean.vrange = [vmin, vmax]mean.ErrorBars = PTR_NEW()mean.Grid1 = GKVsd_GridCopy(grid)meanObj = OBJ_NEW('GKVs1D', mean)std = meanstd.mnemonic = 'STD_' + self.mnemonicstd.title = '!4r!X{' + self.title + '}'std.units = self.unitsstd.values = PTR_NEW(SQRT(REFORM(moments[1,*])))vmin = GKVsd_MIN(SQRT(REFORM(moments[1,*])), MAX=vmax)std.vrange = [vmin, vmax]std.Grid1 = GKVsd_GridCopy(grid)stdObj = OBJ_NEW('GKVs1D', std)variance = stdvariance.mnemonic = 'Var_' + self.mnemonicvariance.title = '!4r!X!U2!N{' + self.title + '}'variance.units = '(' + self.units + ')!U2!N'variance.values = PTR_NEW(REFORM(moments[1,*]))vmin = GKVsd_MIN(REFORM(moments[1,*]), MAX=vmax)variance.vrange = [vmin, vmax]variance.Grid1 = GKVsd_GridCopy(grid)varianceObj = OBJ_NEW('GKVs1D', variance)skewness = varianceskewness.mnemonic = 'Skew_' + self.mnemonicskewness.title = '!4c!X!D1!N{' + self.title + '}'skewness.units = ''skewness.values = PTR_NEW(REFORM(moments[2,*]))vmin = GKVsd_MIN(moments[2,*], MAX=vmax)skewness.vrange = [vmin, vmax]skewness.Grid1 = GKVsd_GridCopy(grid)skewnessObj = OBJ_NEW('GKVs1D', skewness)kurtosis = skewnesskurtosis.mnemonic = 'Kur_' + self.mnemonickurtosis.title =  '!4c!X!D2!N{' + self.title + '}'kurtosis.units = ''kurtosis.values = PTR_NEW(REFORM(moments[3,*]))vmin = GKVsd_MIN(moments[3,*], MAX=vmax)kurtosis.vrange = [vmin, vmax]kurtosis.Grid1 = GKVsd_GridCopy(grid)kurtosisObj = OBJ_NEW('GKVs1D', kurtosis);; Prepare output structure;name = 'Stats_' + self.mnemonicresult -> trashresult = {Name:name, mean:meanObj, std:stdObj, variance:varianceObj, skewness:skewnessObj, kurtosis:kurtosisObj};; and we're done ...;RETURN, resultEND ; ****** GKVs4D::Stats_vs ****** ;