;; *****************************************************************************************************************; ******************************************     Copyright Notice     *********************************************; *                                                                                                               *; *  This work was produced at the University of California, Lawrence Livermore National Laboratory (UC LLNL)     *; *  under contract no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy (DOE) and The Regents   *; *  of the University of California (University) for the operation of UC LLNL. Copyright is reserved to the      *; *  University for purposes of controlled dissemination, commercialization through formal licensing, or other    *; *  disposition under terms of Contract 48; DOE policies, regulations and orders; and U.S. statutes. The rights  *; *  of the Federal Government are reserved under Contract 48 subject to the restrictions agreed upon by the DOE  * ; *  and University as allowed under DOE Acquisition Letter 97-1.                                                 *; *                                                                                                               *; *****************************************************************************************************************;; *****************************************************************************************************************; **********************************************     DISCLAIMER     ***********************************************; *                                                                                                               *; *  This work was prepared as an account of work sponsored by an agency of the United States Government.         *; *  Neither the United States Government nor the University of California nor any of their employees, makes      *; *  any warranty, express or implied, or assumes any liability or responsibility for the accuracy, completeness, *; *  or usefulness  *of any information, apparatus, product, or process disclosed, or represents that its use     *; *  would not infringe privately-owned rights.  Reference herein to any specific commercial products, process,   *; *  or service by trade name, trademark, manufacturer or otherwise does not necessarily constitute or imply its  *; *  endorsement, recommendation, or favoring by the United States Government or the University of California.    *; *  The views and opinions of authors expressed herein do not necessarily state or reflect those of the United   *; *  States Government or the University of California, and shall not be used for advertising or product          *; *  endorsement purposes.                                                                                        *; *                                                                                                               *; *****************************************************************************************************************;;; Defining routine for 3-dimensional signal objects;; Written by W.M. Nevins;	1/31/00;FUNCTION GKVs3D::AxisNumber, stringIn, Debug=d;; Returns number of axis whose mnemonic matches 'stringIn'; If there is no match, returns 0; ; Written by W.M. Nevins;	2/20/00;debug=0result=0IF(N_ELEMENTS(d) NE 0) THEN debug=dresult = self -> GKVs2D::AxisNumber(stringIn, debug=debug)axis3Mnemonic = STRTRIM(self.Grid3.mnemonic, 2)IF( STRCMP(stringIn, axis3Mnemonic, /FOLD_CASE) ) THEN result = 3RETURN, resultEND ; ****** GKVs3D::AxisNumber ****** ;FUNCTION GKVs3D::GetAxis, structure, Debug=d;; Searches 'structure' for tags which are the same as the mnemonics of axis1, axis2, and axis3; Returns a structure with tags 'axis1', 'axis2', and 'axis3'.  ; The associated values are whatever values were associated with the corresponding mnemonic.; ; Written by W.M. Nevins;	2/20/00;debug=0otherTags = 0IF(N_ELEMENTS(d) NE 0) THEN debug=d;; Check for axis1 and axis2 mnemonics by calling GKVs2D::GetAxis;result2 = self -> GKVs2D::GetAxis(structure, Debug=debug);; Structure now contains input structure with tag to mnemonic of axis1 and axis2 (if found) deleted;result = {axis1:result2.axis1, axis2:result2.axis2, axis3:'no match'}IF(N_ELEMENTS(structure) EQ 0) THEN RETURN, result			; Structure is undefinedIF(TypeOf(structure) EQ 2) THEN RETURN, result				; No tags were left to returnnTags = N_TAGS(structure)IF(nTags EQ 0) THEN RETURN, resulttagNames = TAG_NAMES(structure)tagNames = STRTRIM(tagNames, 2)							; Remove both leading and trailing blankscommand_str = 'structure = {'axisMnemonic = STRTRIM(self.Grid3.mnemonic)				; Remove both leading and trailing blanksFOR i=0, ntags-1 DO BEGIN								; Search tags of 'structure'	IF( STRCMP(axisMnemonic, tagNames[i], /FOLD_CASE) ) THEN BEGIN		result = {axis1:result2.axis1, axis2:result2.axis2, axis3:structure.(i) }													; If multiple occurances of axis2 mnemonic in 'structure'	ENDIF ELSE BEGIN								;	only the LAST occurance is signifacant		i_str = STRING(i, FORMAT='(I3)')				; Construct command string for 'Nstructure'		i_str = STRTRIM(i_str, 2)						; Remove both leading and trailing blanks		IF (otherTags NE 0) THEN command_str = command_str + ', '		command_str = command_str + tagNames[i] + ':' + 'structure.(' + i_str + ')'		otherTags = otherTags + 1	ENDELSEENDFORcommand_str = command_str + '}'IF(otherTags NE 0) THEN BEGIN	ok = EXECUTE(command_str)ENDIF ELSE BEGIN	structure = -1ENDELSERETURN, resultEND ; ****** GKVs3D::GetAxis ****** ;FUNCTION GKVs3D::AxisIndex, axisNumber, value, Debug=d;; We should only get here if axisNumber is � 3.  ; Function returns index of axisNumber^th  Grid closest to 'value';debug=0IF(N_ELEMENTS(d) NE 0) then debug=dIF(axisNumber GT 3) THEN BEGIN	MESSAGE, 'axisNumber � 3', INFORMATIONAL=d	RETURN, 0ENDIFaxisStr = STRING(axisNumber,  FORMAT='(I1)')commandStr = 'temp = (*self.Grid' + axisStr + '.values - value)^2'ok = EXECUTE(commandStr)eps=MIN(temp,index)RETURN, indexEND ; ****** GKVs3D::AxisIndex ****** ;FUNCTION GKVs3D::GetValues, All=all, open=open;; Returns pointer to an array containing values which fall within the ; signal window of 'self';;	Written by W.M. Nevins;	2/6/00;iimax = N_ELEMENTS(*self.Grid1.values) - 1IF(KEYWORD_SET(open)) THEN BEGIN	IF(self.grid1.boundary EQ "periodic (closed)") THEN iimax=iimax-1 ENDIFimin = self.Grid1.irange[0]imax = self.Grid1.irange[1] < iimaxIF N_ELEMENTS(all) THEN BEGIN	imin = 0	imax = iimaxENDIFjjmax = N_ELEMENTS(*self.Grid2.values) - 1IF(KEYWORD_SET(open)) THEN BEGIN	IF(self.grid2.boundary EQ "periodic (closed)") THEN jjmax=jjmax-1 ENDIFjmin = self.Grid2.irange[0]jmax = self.Grid2.irange[1] < jjmaxIF N_ELEMENTS(all) THEN BEGIN	jmin = 0	jmax = jjmaxENDIFkkmax = N_ELEMENTS(*self.Grid3.values) - 1IF(KEYWORD_SET(open)) THEN BEGIN	IF(self.grid3.boundary EQ "periodic (closed)") THEN kkmax=kkmax-1 ENDIFkmin = self.Grid3.irange[0]kmax = self.Grid3.irange[1] < kkmaxIF N_ELEMENTS(all) THEN BEGIN	kmin = 0	kmax = kkmaxENDIFvalues = (*self.values)[imin:imax, jmin:jmax, kmin:kmax]RETURN, PTR_NEW(values)END ; ****** GKVs3D::GetValues ******FUNCTION GKVs3D::GetErrors, All=all;; Returns pointer to an array containing errorBars which fall within the ; signal window of 'self';;	Written by W.M. Nevins;	10/10/00;imin = self.Grid1.irange[0]imax = self.Grid1.irange[1]IF N_ELEMENTS(all) THEN BEGIN	imin = 0	imax = N_ELEMENTS(self.Grid1.values) - 1ENDIFjmin = self.Grid2.irange[0]jmax = self.Grid2.irange[1]IF N_ELEMENTS(all) THEN BEGIN	jmin = 0	jmax = N_ELEMENTS(self.Grid2.values) - 1ENDIFkmin = self.Grid3.irange[0]kmax = self.Grid3.irange[1]IF N_ELEMENTS(all) THEN BEGIN	kmin = 0	kmax = N_ELEMENTS(self.Grid3.values) - 1ENDIFerrors = (*self.ErrorBars)[imin:imax, jmin:jmax, kmin:kmax]RETURN, PTR_NEW(errors)END ; ****** GKVs3D::GetErrors ******FUNCTION GKVs3D::SameGrid, argObj, All=all;; Returns 1 if 'self' and argObj have same grid, 0 otherwise;;	Written 2/6/00;	by W.M. Nevins;selfDims = self  -> NumDims()argDims  = argObj-> NumDims()IF(argDims NE selfDims) THEN RETURN, 0imin = self.Grid3.irange[0]imax = self.Grid3.irange[1]IF KEYWORD_SET(all) THEN BEGIN	imin = 0	imax = N_ELEMENTS(*self.Grid3.values) - 1ENDIFsGrid = (*self.Grid3.values)[imin:imax]iargmin = argObj.Grid3.irange[0]iargmax = argObj.Grid3.irange[1]IF KEYWORD_SET(all) THEN BEGIN	iargmin = 0	iargmax = N_ELEMENTS(*argObj.Grid3.values) - 1ENDIFIF((imax-imin) NE (iargmax-iargmin)) THEN RETURN, 0argGrid = (*argObj.Grid3.values)[iargmin:iargmax]Err = TOTAL((sGrid - argGrid)^2)/(1+imax-imin)L1 = sGrid[imax-imin] - sGrid[0]d1 = L1/(1+imax-imin)IF(ERR LT 1.e-3*(d1^2)) THEN RETURN, self -> GKVs2D::SameGrid(argObj)RETURN, 0END ; ****** GKVs3D::SameGrid ****** ;FUNCTION GKVs3D::Interpolate, arg;; Interpolate values from self onto the signal window of arg's grid.;IF (OBJ_ISA(arg, 'GKVs3D') NE 1) THEN BEGIN	MESSAGE, "Argument is not a valid GKVs3D object", /INFORMATIONAL	RETURN, 0ENDIF;; Check for common units, independent variable, interval;IF (	(self.Grid1.units NE arg.Grid1.units) OR 	$	(self.Grid2.units NE arg.Grid2.units) OR	$	(self.Grid3.units NE arg.Grid3.units) ) 	THEN BEGIN	MESSAGE, "Incompatible units (independent variables)", /INFORMATIONAL	RETURN, 0ENDIFIF (	(self.Grid1.mnemonic NE arg.Grid1.mnemonic) OR 	$	(self.Grid2.mnemonic NE arg.Grid2.mnemonic) OR	$	(self.Grid3.mnemonic NE arg.Grid3.mnemonic)) 	THEN BEGIN	MESSAGE, "Interpolate:  Incompatible independent variables", /INFORMATIONAL	RETURN, 0ENDIFIF(self -> SameGRID(arg)) THEN BEGIN	MESSAGE, "Objects have common grid, no interpolation necessary", /INFORMATIONAL	result = self -> MakeCopy()	result -> Restrict	RETURN, resultENDIFx1 = *self.Grid1.values					; *1 -- grid values of self (Obj to be interpolated)x2 =  *arg.Grid1.values					; *2 -- grid values of arg  (target grid)y1 = *self.Grid2.valuesy2 =  *arg.Grid2.valuesz1 = *self.Grid3.valuesz2 =  *arg.Grid3.valuesvalues1 = *self.values					; Get values of to be interpolatedimin = arg.Grid1.irange[0]				; Get range of indices on target gridimax = arg.Grid1.irange[1]jmin = arg.Grid2.irange[0]jmax = arg.Grid2.irange[1]kmin = arg.Grid3.irange[0]kmax = arg.Grid3.irange[1]x = x2[imin:imax]					; axis 1 for target gridy = y2[jmin:jmax]					; axis 2 for target gridz = z2[kmin:kmax]					; axis 3 for target grid;; Get index into old grid arrays (that is, those of 'self') for each element of the new grid arrays (that is, those of 'arg').;jjx = VALUE_LOCATE(x1,x)jjy = VALUE_LOCATE(y1,y)jjz = VALUE_LOCATE(z1,z);; jjx, jjy, jjz will be = -1 if new grid point does not lie within range of old grid points.; First create jx, jy, jz arrays (with jx = jjx > 0jy = jjy > 0jz = jjz > 0;; Compute old grid spacing;info = SIZE(values1)nx1 = info[1] - 1ny1 = info[2] - 1nz1 = info[3] - 1dx1 = x1[1:nx1] - x1[0:(nx1-1)]dy1 = y1[1:ny1] - y1[0:(ny1-1)]dz1 = z1[1:nz1] - z1[0:(nz1-1)];; Compute fractional "address" of new x and y grid points within old grid;sx = jx + ((x - x1[jx])/dx1[jx])*(jjx GT 0)		; the factor (jjx GT 0) has the effect of zeroing outsy = jy + ((y  -y1[jy])/dy1[jy])*(jjy GT 0)		;  this term for points outside of target grid.sz = jz + ((z  -z1[jz])/dz1[jz])*(jjz GT 0)values = INTERPOLATE(values1,sx,sy,sz, /GRID)	; Interpolate input values to target gridresult = self -> MakeCopy(/NoValues, /NoErrorBars)PTR_FREE, result.values					; Load pointer to interpolated valuesresult.values = PTR_NEW(values)				;	into 'result'vmin = GKVsd_MIN(values, MAX=vmax)IF(vmax EQ vmin) THEN vmax = vmin+1result.vrange = [vmin, vmax]PTR_FREE, result.Grid1.values			result.Grid1.values = PTR_NEW(x)			; Load Grid1			result.Grid1.uniform = GKVsd_UniformGrid(x)	; 	...result.Grid1.range=arg.Grid1.range			result.Grid1.irange = [0, imax-imin]PTR_FREE, result.Grid2.values				; Load Grid2result.Grid2.values = PTR_NEW(y)			;	...result.Grid2.uniform = GKVsd_UniformGrid(y)result.Grid2.range = arg.Grid2.rangeresult.Grid2.irange = [0, jmax -jmin]PTR_FREE, result.Grid3.values				; Load Grid3result.Grid3.values = PTR_NEW(z)			;	...result.Grid3.uniform = GKVsd_UniformGrid(z)result.Grid3.range = arg.Grid3.rangeresult.Grid3.irange = [0, kmax-kmin]IF PTR_VALID(self.ErrorBars) THEN BEGIN			; Interpolate error bars...	error1 = *self.ErrorBars			;	(probably we could think	errors = INTERPOLATE(error1,sx,sy,sz, /GRID)	;	 of something a bit more	PTR_FREE, result.ErrorBars			;	 rigorous?)	result.ErrorBars = PTR_NEW(errors)ENDIFRETURN, resultEND ; ***** GKVs3D::Interpolate ***** ;FUNCTION GKVs3D::MakeCopy, _Extra=extra;; Make "deep" copy of self;result = self -> GKVs2D::MakeCopy( _Extra=extra)	; Creates new GKVsxD objects, and										; 	copies elements of GKVs2D classresult.Grid3 = GKVsd_GridCopy(self.Grid3)			; Make 'deep' copy the Grid-class structure Grid3,			RETURN, resultEND ; ***** GKVs3D::MakeCopy ***** ;		FUNCTION GKVs3D::Plus, argg, title=title, mnemonic=mnemonic, units=units;; Define basic arithmetic operation:  addition;arggInfo=SIZE(argg)typeIndex = arggInfo[0] + 1arggType = arggInfo(typeIndex)IF(arggType EQ 0) THEN RETURN, 0			; Undefined argumentarg=argg								; Make proxy for argumenttry_again:argInfo = SIZE(arg)						; Get argument variable typeargDims = argInfo[0]typeIndex = argDims + 1argType = argInfo[typeIndex]CASE argType OF7:	BEGIN								; Argument is a String.  Check if it is a valid axis mnemonic		iaxis = self -> AxisIrange(arg)		CASE iaxis OF			1	:	BEGIN						gridValues = *self.Grid1.values						lVals = N_ELEMENTS(gridValues)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = gridValues#Replicate(1,mVals)						argTitle = self.Grid1.title					END			2	:	BEGIN						gridValues = *self.Grid2.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(gridValues)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = Replicate(1,lVals)#gridValues						argTitle = self.Grid2.title					END				3	:	BEGIN						gridValues = *self.Grid3.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(gridValues)						argValues = FLTARR(lVals, mVals, nVals)						FOR l=0, lVals-1 DO argValues[l,*,*] = Replicate(1,mVals)#gridValues						argTitle = self.Grid3.title					END				ELSE	:	BEGIN						MESSAGE, "Illegal argument -- Returning", /INFORMATIONAL						RETURN, 0					END		ENDCASE		result = self -> MakeCopy(/noValues)		selfValues = *self.values		resultValues = selfValues + argValues		result.values =  PTR_NEW(resultValues)		vmin = GKVsd_MIN(resultValues, MAX=vmax)		IF(vmax EQ vmin) THEN vmax = vmin+1		result.vrange = [vmin, vmax]		IF(TypeOf(mnemonic) EQ 7) THEN result.mnemonic = STRCOMPRESS(mnemonic, /REMOVE_ALL)		result.Title = '(' + self.Title + "+" + argTitle + ')'		IF(TypeOf(title) EQ 7) THEN result.title=title		IF(TypeOf(units) EQ 7) THEN result.units=units		END10:	BEGIN								; Argument is a POINTER		arg = *arg						; Dereference pointer		GOTO, try_again					;	and try again.	END11:	BEGIN								; Argument is an Object Reference		IF (OBJ_ISA(arg, 'GKVs3D') EQ 1) THEN BEGIN			IF (self.units NE arg.units) THEN BEGIN				MESSAGE, "Incompatible units (dependent variable)", /INFORMATIONAL				RETURN, 0			ENDIF		;		; Sum data from two GKVs3D objects		;			argCopy = arg -> MakeCopy()			result = argCopy -> Interpolate(self)			IF ( NOT OBJ_VALID(result) ) THEN BEGIN				MESSAGE, "Can't form common grid for independent variables", /INFORMATIONAL				RETURN, 0			ENDIF			argValues = *result.values			imin = self.Grid1.irange[0]			imax = self.Grid1.irange[1]			jmin = self.Grid2.irange[0]			jmax = self.Grid2.irange[1]			kmin = self.Grid3.irange[0]			kmax = self.Grid3.irange[1]			selfValues = (*self.values)[imin:imax, jmin:jmax, kmin:kmax]			values = argValues + selfValues			PTR_FREE, result.values			result.values = PTR_NEW(values)			vmin = GKVsd_MIN(values, MAX=vmax)			IF(vmax EQ vmin) THEN vmax = vmin+1			result.vrange = [vmin, vmax]			result.mnemonic = ''			; Clear mnemonic field			result.Title = self.Title + " + " + arg.Title		ENDIF 				ENDELSE:		result = self -> GKVsd::Plus(arg)ENDCASERETURN, resultEND ; ***** GKVs3D::Plus ***** ;FUNCTION GKVs3D::Minus, argg, title=title, mnemonic=mnemonic, units=units;; Define basic arithmetic operation:  Subtraction;arggInfo=SIZE(argg)typeIndex = arggInfo[0] + 1arggType = arggInfo(typeIndex)IF(arggType EQ 0) THEN RETURN, 0			; Undefined argumentarg=argg								; Make proxy for argumenttry_again:argInfo = SIZE(arg)						; Get argument variable typeargDims = argInfo[0]typeIndex = argDims + 1argType = argInfo[typeIndex]CASE argType OF7:	BEGIN								; Argument is a String.  Check if it is a valid axis mnemonic		iaxis = self -> AxisIrange(arg)		CASE iaxis OF			1	:	BEGIN						gridValues = *self.Grid1.values						lVals = N_ELEMENTS(gridValues)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = gridValues#Replicate(1,mVals)						argTitle = self.Grid1.title					END			2	:	BEGIN						gridValues = *self.Grid2.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(gridValues)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = Replicate(1,lVals)#gridValues						argTitle = self.Grid2.title					END				3	:	BEGIN						gridValues = *self.Grid3.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(gridValues)						argValues = FLTARR(lVals, mVals, nVals)						FOR l=0, lVals-1 DO argValues[l,*,*] = Replicate(1,mVals)#gridValues						argTitle = self.Grid3.title					END				ELSE	:	BEGIN						MESSAGE, "Illegal argument -- Returning", /INFORMATIONAL						RETURN, 0					END		ENDCASE		result = self -> MakeCopy(/noValues)		selfValues = *self.values		resultValues = selfValues - argValues		result.values =  PTR_NEW(resultValues)		vmin = GKVsd_MIN(resultValues, MAX=vmax)		IF(vmax EQ vmin) THEN vmax = vmin+1		result.vrange = [vmin, vmax]		IF(TypeOf(mnemonic) EQ 7) THEN result.mnemonic = STRCOMPRESS(mnemonic, /REMOVE_ALL)		result.Title = '(' + self.Title + "-" + argTitle + ')'		IF(TypeOf(title) EQ 7) THEN result.title=title		IF(TypeOf(units) EQ 7) THEN result.units=units		END10:	BEGIN								; Argument is a POINTER		arg = *arg						; Dereference pointer		GOTO, try_again					;	and try again.	END11:	BEGIN								; Argument is an Object Reference		IF (OBJ_ISA(arg, 'GKVs3D') EQ 1) THEN BEGIN			IF (self.units NE arg.units) THEN BEGIN				MESSAGE, "Incompatible units (dependent variable)", /INFORMATIONAL				RETURN, 0			ENDIF		;		; Difference of data from two GKVs3D objects		;			argCopy = arg -> MakeCopy()			result = argCopy -> Interpolate(self)			IF ( NOT OBJ_VALID(result) ) THEN BEGIN				MESSAGE, "Can't form common grid for independent variables", /INFORMATIONAL				RETURN, 0			ENDIF			argValues = *result.values			imin = self.Grid1.irange[0]			imax = self.Grid1.irange[1]			jmin = self.Grid2.irange[0]			jmax = self.Grid2.irange[1]			kmin = self.Grid3.irange[0]			kmax = self.Grid3.irange[1]			selfValues = (*self.values)[imin:imax, jmin:jmax, kmin:kmax]			values = selfValues - argValues			PTR_FREE, result.values			result.values = PTR_NEW(values)			vmin = GKVsd_MIN(values, MAX=vmax)			IF(vmax EQ vmin) THEN vmax = vmin+1			result.vrange = [vmin, vmax]			result.mnemonic = ''			; Clear mnemonic field			result.Title = self.Title + " - " + arg.Title		ENDIF 				ENDELSE:		result = self -> GKVsd::Minus(arg)ENDCASERETURN, resultEND ; ***** GKVs3D::Minus ***** ;FUNCTION GKVs3D::Times, argg, title=title, mnemonic=mnemonic, units=units;; Define basic arithmetic operation:  Multiplication;arggInfo=SIZE(argg)typeIndex = arggInfo[0] + 1arggType = arggInfo(typeIndex)IF(arggType EQ 0) THEN RETURN, 0			; Undefined argumentarg=argg								; Make proxy for argumenttry_again:argInfo = SIZE(arg)						; Get argument variable typeargDims = argInfo[0]typeIndex = argDims + 1argType = argInfo[typeIndex]CASE argType OF7:	BEGIN								; Argument is a String.  Check if it is a valid axis mnemonic		iaxis = self -> AxisIrange(arg)		CASE iaxis OF			1	:	BEGIN						gridValues = *self.Grid1.values						lVals = N_ELEMENTS(gridValues)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = gridValues#Replicate(1,mVals)						argTitle = self.Grid1.title						argUnits = self.Grid1.units					END			2	:	BEGIN						gridValues = *self.Grid2.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(gridValues)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = Replicate(1,lVals)#gridValues						argTitle = self.Grid2.title						argUnits = self.Grid2.units					END				3	:	BEGIN						gridValues = *self.Grid3.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(gridValues)						argValues = FLTARR(lVals, mVals, nVals)						FOR l=0, lVals-1 DO argValues[l,*,*] = Replicate(1,mVals)#gridValues						argTitle = self.Grid3.title						argUnits = self.Grid3.units					END				ELSE	:	BEGIN						MESSAGE, "Illegal argument -- Returning", /INFORMATIONAL						RETURN, 0					END		ENDCASE		result = self -> MakeCopy(/noValues, /NoErrorBars)		selfValues = *self.values		resultValues = selfValues*argValues		result.values =  PTR_NEW(resultValues)		vmin = GKVsd_MIN(resultValues, MAX=vmax)		IF(vmax EQ vmin) THEN vmax = vmin+1		result.vrange = [vmin, vmax]		IF PTR_VALID(self.ErrorBars) THEN BEGIN			errorBars = *self.ErrorBars*argValues			result.ErrorBars = PTR_NEW(errorBars)		ENDIF		IF(TypeOf(mnemonic) EQ 7) THEN result.mnemonic = STRCOMPRESS(mnemonic, /REMOVE_ALL)		result.Title = '(' + self.Title + "*" + argTitle + ')'		IF(TypeOf(title) EQ 7) THEN result.title=title		result.units = '(' + self.units + ')*(' + argUnits + ')'		IF(TypeOf(units) EQ 7) THEN result.units=units		END10:	BEGIN								; Argument is a POINTER		arg = *arg						; Dereference pointer		GOTO, try_again					;	and try again.	END11:	BEGIN								; Argument is an Object Reference		IF (OBJ_ISA(arg, 'GKVs3D') EQ 1) THEN BEGIN		;		; Multiply data from two GKVs3D objects		;			argCopy = arg -> MakeCopy()			result = argCopy -> Interpolate(self)			IF ( NOT OBJ_VALID(result) ) THEN BEGIN				MESSAGE, "Can't form common grid for independent variables", /INFORMATIONAL				RETURN, 0			ENDIF			argValues = *result.values			imin = self.Grid1.irange[0]			imax = self.Grid1.irange[1]			jmin = self.Grid2.irange[0]			jmax = self.Grid2.irange[1]			kmin = self.Grid3.irange[0]			kmax = self.Grid3.irange[1]			selfValues = (*self.values)[imin:imax, jmin:jmax, kmin:kmax]			values = selfValues*argValues			PTR_FREE, result.values			result.values = PTR_NEW(values)			vmin = GKVsd_MIN(values, MAX=vmax)			IF(vmax EQ vmin) THEN vmax = vmin+1			result.vrange = [vmin, vmax]			result.mnemonic = ''			; Clear mnemonic field			result.Title = self.Title + " * " + arg.Title		ENDIF 				ENDELSE:		result = self -> GKVsd::Times(arg)ENDCASERETURN, resultEND ; ***** GKVs3D::Times ***** ;FUNCTION GKVs3D::Over, argg, title=title, mnemonic=mnemonic, units=units;; Define basic arithmetic operation:  Division;arggInfo=SIZE(argg)typeIndex = arggInfo[0] + 1arggType = arggInfo(typeIndex)IF(arggType EQ 0) THEN RETURN, 0			; Undefined argumentarg=argg								; Make proxy for argumenttry_again:argInfo = SIZE(arg)						; Get argument variable typeargDims = argInfo[0]typeIndex = argDims + 1argType = argInfo[typeIndex]CASE argType OF7:	BEGIN								; Argument is a String.  Check if it is a valid axis mnemonic		iaxis = self -> AxisIrange(arg)		CASE iaxis OF			1	:	BEGIN						gridValues = *self.Grid1.values						lVals = N_ELEMENTS(gridValues)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = gridValues#Replicate(1,mVals)						argTitle = self.Grid1.title						argUnits = self.Grid1.units					END			2	:	BEGIN						gridValues = *self.Grid2.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(gridValues)						nVals = N_ELEMENTS(*self.Grid3.values)						argValues = FLTARR(lVals, mVals, nVals)						FOR n=0, nVals-1 DO argValues[*,*,n] = Replicate(1,lVals)#gridValues						argTitle = self.Grid2.title						argUnits = self.Grid2.units					END				3	:	BEGIN						gridValues = *self.Grid3.values						lVals = N_ELEMENTS(*self.Grid1.values)						mVals = N_ELEMENTS(*self.Grid2.values)						nVals = N_ELEMENTS(gridValues)						argValues = FLTARR(lVals, mVals, nVals)						FOR l=0, lVals-1 DO argValues[l,*,*] = Replicate(1,mVals)#gridValues						argTitle = self.Grid3.title						argUnits = self.Grid3.units					END				ELSE	:	BEGIN						MESSAGE, "Illegal argument -- Returning", /INFORMATIONAL						RETURN, 0					END		ENDCASE		result = self -> MakeCopy(/noValues, /NoErrorBars)		selfValues = *self.values		resultValues = selfValues/argValues		result.values =  PTR_NEW(resultValues)		vmin = GKVsd_MIN(resultValues, MAX=vmax)		IF(vmax EQ vmin) THEN vmax = vmin+1		result.vrange = [vmin, vmax]		IF PTR_VALID(self.ErrorBars) THEN BEGIN			errorBars = *self.ErrorBars/argValues			result.ErrorBars = PTR_NEW(errorBars)		ENDIF		IF(TypeOf(mnemonic) EQ 7) THEN result.mnemonic = STRCOMPRESS(mnemonic, /REMOVE_ALL)		result.Title = '(' + self.Title + "/" + argTitle + ')'		IF(TypeOf(title) EQ 7) THEN result.title=title		result.units = '(' + self.units + ')/(' + argUnits + ')'		IF(TypeOf(units) EQ 7) THEN result.units=units		END10:	BEGIN								; Argument is a POINTER		arg = *arg						; Dereference pointer		GOTO, try_again					;	and try again.	END11:	BEGIN								; Argument is an Object Reference		IF (OBJ_ISA(arg, 'GKVs3D') EQ 1) THEN BEGIN		;		; Divide data from two GKVs3D objects		;			argCopy = arg -> MakeCopy()			result = argCopy -> Interpolate(self)			IF ( NOT OBJ_VALID(result) ) THEN BEGIN				MESSAGE, "Can't form common grid for independent variables", /INFORMATIONAL				RETURN, 0			ENDIF			argValues = *result.values			imin = self.Grid1.irange[0]			imax = self.Grid1.irange[1]			jmin = self.Grid2.irange[0]			jmax = self.Grid2.irange[1]			kmin = self.Grid3.irange[0]			kmax = self.Grid3.irange[1]			selfValues = (*self.values)[imin:imax, jmin:jmax, kmin:kmax]			values = selfValues/argValues			PTR_FREE, result.values			result.values = PTR_NEW(values)			vmin = GKVsd_MIN(values, MAX=vmax)			IF(vmax EQ vmin) THEN vmax = vmin+1			result.vrange = [vmin, vmax]			result.mnemonic = ''			; Clear mnemonic field			result.Title = self.Title + " / " + arg.Title		ENDIF 				ENDELSE:		result = self -> GKVsd::Over(arg)ENDCASERETURN, resultEND ; ***** GKVs3D::Over ***** ;FUNCTION GKVs3D_Gen, Nx=n1, Ny=n2, Nz=n3, Amplitude=a, kx=k1, ky=k2, 	$				kz=k3, Del_k=bandwidth;; Set up sample GKVs3D signal object;nx=64Lny=64Lnz=64LIF ( N_ELEMENTS(n1) NE 0 ) THEN nx=n1IF ( N_ELEMENTS(n2) NE 0 ) THEN ny=n2IF ( N_ELEMENTS(n3) NE 0 ) THEN nz=n3dx = 2*!PI/(nx-1)dy = 2*!PI/(ny-1)dz = 2*!PI/(nz-1)amplitude=1.IF KEYWORD_SET(a)  then amplitude=akx = 2.ky = 2.kz = 2.Del_k = 2.IF N_ELEMENTS(k1) then kx=k1IF N_ELEMENTS(k2) then ky=k2IF N_ELEMENTS(k3) then kz=k3IF N_ELEMENTS(bandwidth) then del_k=bandwidthxgrid = dx*indgen(nx)ygrid = dy*indgen(ny)zgrid = dz*indgen(nz)i=COMPLEX(0.,1.)argx= -0.5d*((INDGEN(nx) - kx)^2/Del_k > (-30.0d))argy= -0.5d*((INDGEN(ny) - ky)^2/Del_k > (-30.0d))argz= -0.5d*((INDGEN(nz) - kz)^2/Del_k > (-30.0d))rarray=RANDOMN(seed, nx, ny, nz)iarray=RANDOMN(seed, nx, ny, nz)array=COMPLEX(rarray, iarray)FOR i=0, nz-1 DO array(*,*,i)=( exp(argx)#exp(argy))*array(*,*,i)*exp(argz(i))array=FFT(array, 1, /OVERWRITE)msarray= TOTAL(array*CONJ(array))/( LONG(nx)*LONG(ny)*LONG(nz) ) values=amplitude*array/sqrt(msarray)vmin = GKVsd_MIN(values, MAX=vmax)IF(vmax EQ vmin) THEN vmax = vmin+1Indices = REPLICATE('*', 3)signal={GKVs3D};; GKVsd tags;	signal.mnemonic	= "sgen3D"	signal.Title	= "!13Title!N!X"	signal.Indices	= PTR_NEW(Indices)	signal.units	= "units"	signal.values	= ptr_new(values)	signal.vrange	= [vmin, vmax]	signal.codeName	= "GKV selftest"	signal.codePI	= "W.M. Nevins"		signal.RunID	= "Null run"	signal.FileID	= "Self-Generated";; Grid1 tags;	signal.Grid1.mnemonic	= 'x'	signal.Grid1.title 	= "x-title"	signal.Grid1.units 	= "x-units"	signal.Grid1.values  = ptr_new(xgrid)	signal.Grid1.boundary	= "open"	signal.Grid1.range 	= [xgrid[0], xgrid[nx-1]] 	signal.Grid1.irange 	= [0, nx-1];; Grid2 tags;	signal.Grid2.mnemonic	= 'y'	signal.Grid2.title 	= "y-title"	signal.Grid2.units 	= "y-units"	signal.Grid2.values 	= PTR_NEW(ygrid)	signal.Grid2.boundary	= "open"	signal.Grid2.range	= [ygrid[0], ygrid[ny-1]]	signal.Grid2.irange	= [0, ny-1];; Grid3 tags;	signal.Grid3.mnemonic	= 'z'	signal.Grid3.title 	= "z-title"	signal.Grid3.units 	= "z-units"	signal.Grid3.values 	= PTR_NEW(zgrid)	signal.Grid3.boundary	= "open"	signal.Grid3.range	= [zgrid[0], zgrid[nz-1]]	signal.Grid3.irange	= [0, nz-1];; Create signal object;	signal_obj=OBJ_NEW("GKVs3D", signal) RETURN, signal_objEND ; ***** GKVs3D_Gen ***** ;PRO GKVs3D::GET, axis=axisID,  GridMnemonic = GridMnemonic, GridTitle=GridTitle, 				$			GridUnits=GridUnits, GridValues=GridValues, boundary=boundary, uniform=uniform,		$			range=range, irange=irange, mnemonic=mnemonic, Title=Title, Indices=indices, 		$			units=units, values=values, vrange=vrange, ErrorBars=ErrorBars, CodeName=CodeName,	$			CodePI=CodePI, RunID=RunID, FileID=FIleID, _Extra=extra	;; Get values of elements of the realization of the GRID class, Grid3;; and then call GKVs2D::GET to get values of elements of the GKVs2D Class.;; This call will be used polymorphically, so 'self' may be of class GKVs3D,; or any or its subclasses;IDinfo = SIZE(axisID)IDtype = IDinfo[IDinfo[0] + 1]CASE IDtype OF	1:	IF(axisID EQ 3) THEN 	$			GKVsd_GetGrid, self.Grid3,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$								GridUnits=GridUnits,	GridValues=GridValues, 			$								boundary=boundary, uniform=uniform,range=range, 		$								irange=irange, _Extra=extra	2:	IF(axisID EQ 3) THEN 	$			GKVsd_GetGrid, self.Grid3,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$								GridUnits=GridUnits,	GridValues=GridValues, 			$								boundary=boundary, uniform=uniform,range=range, 		$								irange=irange, _Extra=extra	3:	IF(axisID EQ 3) THEN 	$			GKVsd_GetGrid, self.Grid3,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$								GridUnits=GridUnits,	GridValues=GridValues, 			$								boundary=boundary, uniform=uniform,range=range, 		$								irange=irange, _Extra=extra	7:	IF(axisID EQ self.Grid3.mnemonic) THEN 	$			GKVsd_GetGrid, self.Grid3,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$								GridUnits=GridUnits,	GridValues=GridValues, 			$								boundary=boundary, uniform=uniform,range=range, 		$								irange=irange, _Extra=extraELSE	 :	; just continue on else ENDCASEself -> GKVs2D::GET, axis=axisID,  GridMnemonic = GridMnemonic, GridTitle=GridTitle, 				$			GridUnits=GridUnits, GridValues=GridValues, boundary=boundary, uniform=uniform,		$			range=range, irange=irange, mnemonic=mnemonic, Title=Title, Indices=indices, 		$			units=units, values=values, vrange=vrange, ErrorBars=ErrorBars, CodeName=CodeName,	$			CodePI=CodePI, RunID=RunID, FileID=FIleID, _Extra=extraRETURNEND ; ****** GKVs3D::GET ****** ;PRO GKVs3D::SET,axis=axisID,  GridMnemonic = GridMnemonic, GridTitle=GridTitle, 				$			GridUnits=GridUnits, GridValues=GridValues, boundary=boundary, uniform=uniform,		$			range=range, irange=irange, mnemonic=mnemonic, Title=Title, Indices=indices, 		$			units=units, values=values, vrange=vrange, ErrorBars=ErrorBars, CodeName=CodeName,	$			CodePI=CodePI, RunID=RunID, FileID=FIleID, _Extra=extra;; Get values of elements of the realization of the GRID class, Grid3;; and then call GKVs2D::GET to get values of elements of the GKVs2D Class.;; This call will be used polymorphically, so 'self' may be of class GKVs3D,; or any or its subclasses;arg = self.Grid3IDinfo = SIZE(axisID)IDtype = IDinfo[IDinfo[0] + 1]CASE IDtype OF	1:	IF(axisID EQ 3) THEN 	$			GKVsd_SetGrid, arg,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$							GridUnits=GridUnits,	GridValues=GridValues, 			$							boundary=boundary, uniform=uniform,range=range, 		$							irange=irange, _Extra=extra	2:	IF(axisID EQ 3) THEN 	$			GKVsd_SetGrid, arg,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$							GridUnits=GridUnits,	GridValues=GridValues, 			$							boundary=boundary, uniform=uniform,range=range, 		$							irange=irange, _Extra=extra	3:	IF(axisID EQ 3) THEN 	$			GKVsd_SetGrid, arg,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$							GridUnits=GridUnits,	GridValues=GridValues, 			$							boundary=boundary, uniform=uniform,range=range, 		$							irange=irange, _Extra=extra	7:	IF(axisID EQ self.Grid3.mnemonic) THEN 	$			GKVsd_SetGrid, arg,	GridMnemonic = GridMnemonic, GridTitle=GridTitle, 		$							GridUnits=GridUnits,	GridValues=GridValues, 			$							boundary=boundary, uniform=uniform,range=range, 		$							irange=irange, _Extra=extraELSE	 :	; just continue on else ENDCASEself.Grid3 = argself -> GKVs2D::SET, 	axis=axisID,  GridMnemonic = GridMnemonic, GridTitle=GridTitle, 			$			GridUnits=GridUnits, GridValues=GridValues, boundary=boundary, uniform=uniform,		$			range=range, irange=irange, mnemonic=mnemonic, Title=Title, Indices=indices, 		$			units=units, values=values, vrange=vrange, ErrorBars=ErrorBars, CodeName=CodeName,	$			CodePI=CodePI, RunID=RunID, FileID=FIleID, _Extra=extraRETURNEND ; ****** GKVs3D::SET ****** ;PRO GKVs3D::Info;; Prints information about contents of GKVs3D objects;self -> GKVs2D::InfoPRINT, 'Grid3:'GKVsd_PrintGrid, self.Grid3RETURNEND ; ***** GKVs3D::Info ***** ;Function GKVs3D::INIT, signal;; Preliminary init for testing object methods ...;Catch, error IF error NE 0 then Begin    Catch, /Cancel             ; Cancel error trap    ok=Error_Message(/Trace)   ; print out a trace-back in the output log    RETURN, 0                  ; Return 0 for unsuccessful call to INIT function. ENDIF ;; Set tags for GKVs2D class;ok = self -> GKVs2D::INIT(signal);; Set Tags for Grid3;NumTags=N_TAGS(self.Grid3)FOR itag=0, NumTags-1 DO $	self.Grid3.(itag) = signal.Grid3.(itag);; remove embedded blanks in grid title, mnemonic, and units;self.grid3.title    = STRCOMPRESS(self.grid3.title,    /REMOVE_ALL)self.grid3.mnemonic = STRCOMPRESS(self.grid3.mnemonic, /REMOVE_ALL)self.grid3.units    = STRCOMPRESS(self.grid3.units,    /REMOVE_ALL)IF(PTR_VALID(self.grid3.values)) THEN	 BEGIN	;	; Check for uniform grid	;	self.Grid3.uniform = GKVsd_UniformGrid(self.Grid3.values)	;	; Check if Grid3.range is set ... and set if necessary	;	IF((self.Grid3.range[0] EQ 0.) AND (self.Grid3.range[1] EQ 0.)) THEN $		self.Grid3.range = [MIN(*self.Grid3.Values, Max=max), max]	;	; Check if Grid3.irange is set ... and set if necessary	;	IF((self.Grid3.irange[0] EQ 0) AND (self.Grid3.irange[1] EQ 0)) THEN $		self.Grid3.irange = [0, N_ELEMENTS(*self.Grid3.values)-1]ENDIF;; Return on successful completion;RETURN, okEND ; ***** GKVs3D::INIT ***** ;PRO GKVs3D::CleanUpPTR_FREE, self.Grid3.valuesself -> GKVs2D::CleanUpRETURNEND ; ***** GKVs3D::CleanUp ***** ;	PRO GKVs3D__Definestruct = {	GKVs3D,				$	; "GK Visualization signal (3-D)"		INHERITS GKVs2D,		$	; GKVs3D is a subclass of GKVs2D		GRID3:{GRID}			}	; Include a third 'Grid' class	END ; ***** GKVs3D__Define ***** ;