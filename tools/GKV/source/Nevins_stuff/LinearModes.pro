FUNCTION GKVs1D::FindMax, width=width;; Purpose:;;	This routine finds (and returns) the value of the independent variable at which ;	value of 'self' has its maximum.;; Keywords:;;	width	half width of maximum in self.;; Written by W.M. Nevins;	11/29/01;nDims = self -> NumDims()IF(nDims GT 1) THEN BEGIN	MESSAGE, 'Only implimented in 1-D', /INFORMATIONAL	RETURN, 0ENDIFvalues = *self.valuesmaxVal = MAX(values, imax)self -> GET, axis=1, GridValues=GridPtrGridValues = *GridPtrxmax = GridValues[imax]width = self -> FullWidth()width=width/2.RETURN, xmaxEND ; ****** GKVs1D::FindMax ****** ;FUNCTION GKVs1D::LinearModes, ftAxisIn, xRef=x_ref, _Extra=Extra;; Purpose:;;	This routine expects linear phase of simulation in input (3D) object.;	Returns a structure containing real frequency and growth rate of the;	of fast growing mode at at each k_theta, together with an object array;	containing the (best effort) at exracting the linear mode structures.;;;	'Self' should be a (3D) object containing linear phase of simulation;;	Keywords:;;	;; Written by W.M. Nevins;	11/29/01;nArgs = N_PARAMS()IF(nArgs EQ 0) THEN ftAxisIn = 2IF Query_Integer(ftAxisIn) THEN ftAxis = ftAxisInIF Query_String( ftAxisIn) THEN ftaxis = self -> AxisNumber(ftAxisIn)IF(N_ELEMENTS(ftAxis)EQ 0) THEN BEGIN	MESSAGE, 'LinearModes called with illegal axis identifier', /INFORMATIONAL	PRINT, 'ftAxisIn = ', ftAxisIn	RETURN, 0ENDIFIF( (ftAxis LE 0) OR (ftAxis GT 2) ) THEN BEGIN	MESSAGE, 'LinearModes called with illegal axis identifier', /INFORMATIONAL	PRINT, 'ftAxisIn = ', ftAxisIn	RETURN, 0	ENDIFxRef=0.IF(N_ELEMENTS(x_ref) EQ 1) THEN xRef=x_refCASE ftAxis OF	1	:	BEGIN				xAxis = 2				result = GetKeyWord(self.Grid2.mnemonic, Extra)				IF(TypeOf(result) NE 7) THEN xRef=result			END	2	:	BEGIN				xAxis = 1				result = GetKeyWord(self.Grid1.mnemonic, Extra)				IF(TypeOf(result) NE 7) THEN xRef=result			ENDENDCASEself -> restrictself_k = self -> FFT(ftAxis)CASE ftAxis OF	1	:	ftGrid = self_k.grid1	2	:	ftGrid = self_k.grid2ENDCASEkrange = ftGrid.irangekmin = kRange[1]/2kmax = kRange[1]result=GetKeyWord('kRange', Extra)IF(Query_Integer(result)) THEN BEGIN	IF(N_ELEMENTS(result) GT 1) THEN kmax=result[1]	kmin = kmin + result[0]ENDIFIF(Query_Real(result)) THEN BEGIN	kValues = *(ftGrid.values)	dk=kValues[1] - kvalues[0]	IF(N_ELEMENTS(result) GT 1) THEN kmax=kmin + FIX(result[1]/dk)	kmin = kmin + FIX(result[0]/dk)ENDIFnKs = kmax - kmin + 1tSeries = OBJARR(nKs)wSpects = OBJARR(nKs)kModes  = OBJARR(nKs)omegas  = FLTARR(nKs)omegasPM= FLTARR(nKs)gammas  = FLTARR(nks)gammasPM= FLTARR(nKs)windowIDs = BYTARR(nKs)i=0FOR k=kmin, kmax DO BEGIN	kSlice = self_k -> slice(axis=ftAxis, index=k)	kRef = kSlice -> slice(axis=xAxis, value=xRef)	AbskRef = kRef -> Execute('ABS')	AbskRef-> FIND_SLOPE, /ylog, slope=aa, PMslope=PMaa, xOut=trange	windowIDs[i] = !D.WINDOW		gammas[i]   = aa	gammasPM[i] = PMaa	tSeries[i] = kRef -> MakeCopy()	kSlice -> SignalWindow, t=trange	kRef   -> SignalWindow, t=trange	kSlice -> Restrict	kRef   -> Restrict	nkSlice = kSlice -> TimesExp(-gammas[i])	nkRef   = kRef  -> TimesExp(-gammas[i])	kSpect  = nkRef -> xspect()	omegas[i] = kSpect -> FindMax(width=PMomega)	omegasPM[i] = PMomega	xkSpect = nkSlice -> xspect(ref=kRef)	kModes[i] = xkSpect -> slice(omega=omegas[i])	wSpects[i] = kSpect	i=i+1	kSlice  -> trash	kRef    -> trash	abskRef -> trash	nkSlice -> trash	nkRef   -> trash	xkSpect -> trash	ENDFORFOR i=0,nKs-1 DO WDELETE ; , windowIDs[i]omega = {GKVs1D}FOR i=0, N_TAGS({GKVsd})-1 DO omega.(i) = self.(i)omega.title='!4x!X'omega.mnemonic = 'omega'omega.units = '1/(' + self.grid3.units + ')'indices = REPLICATE('*',1)omega.indices = PTR_NEW(indices)omega.values = PTR_NEW(omegas)FORWARD_FUNCTION GKVsd_MINvmin = GKVsd_MIN(omegas, MAX=vmax)omega.vrange = [vmin,vmax]omega.ErrorBars = PTR_NEW(omegasPM)kGrid = ftGridkValues =(*ftGrid.values)[kmin:kmax]kGrid.values = PTR_NEW(kValues)kGrid.irange=[0,nKs-1]kGrid.range = [ kValues[0], kValues[nKs-1] ]kGrid.boundary = 'open'omega.grid1=kgridomegaObj = OBJ_NEW('GKVs1D', omega)gammaObj = omegaObj -> MakeCopy(/NoValues, /NoErrorBars)vmin = GKVsd_MIN(gammas, MAX=vmax)gammaObj -> set, values=gammas, ErrorBars=gammasPM, vrange=[vmin, vmax], title='!4c!X', mnemonic='gamma'self_k -> trashresult = {	Name	:	'LinearModes'	,	$		tSeries	:	tSeries		,	$		wSpects	:	wSpects		,	$		kModes	:	kModes		,	$		omega	:	omegaObj	,	$		gamma	:	gammaObj	}			RETURN, resultEND ; ****** GKVs1D::LinearModes ****** ;