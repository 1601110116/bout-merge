FUNCTION GKVs2D::XtoK;; Transforms object from configuration space representation; to fourier space representation.;FORWARD_FUNCTION GKVsd_MINvalues=*self.valuesinfo=SIZE(values)IF(info[0] ne 2) then begin	MESSAGE, 'only 2-D for now', /Informational	RETURN, 0ENDIFnx  = info[1]ikx = nxny  = info[2]iky = nyikyplus = (iky+1)/2;; Make array to hold k-space representation of data; (implicitly using reality condition such that only;  positive values of ky need to be saved);kSpaceValues = COMPLEXARR(ikx, ikyplus);; Fourier transform;temp = FFT(values, -1);; load positive values of ky from 'temp' into ; 'kSpaceValues' (the output array);kSpaceValues = temp[*, 0:(ikyplus-1)];; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx.;kxShift = (ikx/2) + 1kSpaceValues = SHIFT(kSpaceValues,  -kxShift, 0);; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0];kxMax = !PI/dxdkx = 2*!PI/lxkxGrid = dkx*(FINDGEN(ikx) - (ikx/2))PTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.mnemonic = 'kx'result.Grid1.title = 'k!Ix!N'result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]result.Grid1.irange = [0,ikx-1]yGrid = *self.Grid2.valuesly = yGrid[ny-1] - yGrid[0]dy = yGrid[1] - yGrid[0]dky = 2*!PI/lykyGrid = dky*FINDGEN(ikyplus)PTR_FREE, result.Grid2.valuesresult.Grid2.values = PTR_NEW(kyGrid)result.Grid2.mnemonic = 'ky'result.Grid2.title = 'k!Iy!N'result.Grid2.range = [0., kyGrid[ikyplus-1]]result.Grid2.irange = [0,ikyplus-1]RETURN, resultEND ; ****** GKVs2D::KtoX ****** ;FUNCTION GKVs3D::XtoK;; Transforms object from configuration space representation; to fourier space representation.  Assumes that the first ; two dimensions correspond to indepent varialbes in configuration; space (e.g., 'x' and 'y'), while the third dimension; is time (which we will not transform over).;values=*self.valuesinfo=SIZE(values)IF(info[0] ne 3) then begin	MESSAGE, 'only up to 3-D for now', /Informational	RETURN, 0ENDIFnx  = info[1]ikx = nxny  = info[2]iky = nyikyplus = (iky+1)/2nt = info[3];; Make array to hold k-space representation of data; (implicitly using reality condition such that only;  positive values of ky need to be saved);kSpaceValues = COMPLEXARR(ikx, ikyplus, nt);; Begin loop over time-slices;FOR it = 0, nt-1 DO BEGIN;; Fourier transform;	temp = FFT(values[*,*,it], -1);; load positive values of ky from 'temp' into ; 'kSpaceValues' (the output array);	kSpaceValues[*,*,it] = temp[*, 0:(ikyplus-1)];ENDFOR;; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx.;kxShift = (ikx/2) + 1kSpaceValues = SHIFT(kSpaceValues,  -kxShift, 0, 0);; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0];kxMax = !PI/dxdkx = 2*!PI/lxkxGrid = dkx*(FINDGEN(ikx) - (ikx/2))PTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.mnemonic = 'kx'result.Grid1.title = 'k!Ix!N'result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]result.Grid1.irange = [0,ikx-1];yGrid = *self.Grid2.valuesly = yGrid[ny-1] - yGrid[0]dy = yGrid[1] - yGrid[0]dky = 2*!PI/lykyGrid = dky*FINDGEN(ikyplus)PTR_FREE, result.Grid2.valuesresult.Grid2.values = PTR_NEW(kyGrid)result.Grid2.mnemonic = 'ky'result.Grid2.title = 'k!Iy!N'result.Grid2.range = [0., kyGrid[ikyplus-1]]result.Grid2.irange = [0,ikyplus-1]RETURN, resultEND ; ****** GKVs3D::XtoK ****** ;