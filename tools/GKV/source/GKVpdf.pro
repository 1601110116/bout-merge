;; *****************************************************************************************************************; ******************************************     Copyright Notice     *********************************************; *                                                                                                               *; *  This work was produced at the University of California, Lawrence Livermore National Laboratory (UC LLNL)     *; *  under contract no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy (DOE) and The Regents   *; *  of the University of California (University) for the operation of UC LLNL. Copyright is reserved to the      *; *  University for purposes of controlled dissemination, commercialization through formal licensing, or other    *; *  disposition under terms of Contract 48; DOE policies, regulations and orders; and U.S. statutes. The rights  *; *  of the Federal Government are reserved under Contract 48 subject to the restrictions agreed upon by the DOE  * ; *  and University as allowed under DOE Acquisition Letter 97-1.                                                 *; *                                                                                                               *; *****************************************************************************************************************;; *****************************************************************************************************************; **********************************************     DISCLAIMER     ***********************************************; *                                                                                                               *; *  This work was prepared as an account of work sponsored by an agency of the United States Government.         *; *  Neither the United States Government nor the University of California nor any of their employees, makes      *; *  any warranty, express or implied, or assumes any liability or responsibility for the accuracy, completeness, *; *  or usefulness  *of any information, apparatus, product, or process disclosed, or represents that its use     *; *  would not infringe privately-owned rights.  Reference herein to any specific commercial products, process,   *; *  or service by trade name, trademark, manufacturer or otherwise does not necessarily constitute or imply its  *; *  endorsement, recommendation, or favoring by the United States Government or the University of California.    *; *  The views and opinions of authors expressed herein do not necessarily state or reflect those of the United   *; *  States Government or the University of California, and shall not be used for advertising or product          *; *  endorsement purposes.                                                                                        *; *                                                                                                               *; *****************************************************************************************************************;;FUNCTION GKVpdf::GKVs1D,	xrange=x_range,  title=T_title, xtitle=x_title,	$			  		ytitle=y_title, yrange=y_range,  			$			  		Exponent=alpha, PPDFs=ppdfs, _Extra=extra;; Form pdf from "Event_Vol" array (as returned by Event_Volume,; which is called by GKVpdf::Init), and make a GKVs1D object with the result;FORWARD_FUNCTION PDFspdf = PDFs(	*self.strPtr, SIZES, PARTIAL_PDF=partial_pdf,		$	       	V_min=min_vol, Exponent=alpha, pdf_error=pdf_error	);; Normalize pdf;y  		= pdf/(self.Lx * self.T)x		=sizes*(self.dx)*(self.dt)pdf_error 	= pdf_error/(self.Lx * self.T)xmin = MIN(sizes, MAX=xmax)xrange=[xmin, xmax]if KEYWORD_SET(x_range) THEN xrange=x_rangetitle = 'PDF for events in ' + self.TitleIF KEYWORD_SET(T_title)	THEN title=T_titlextitle = 'Event Size (' + self.units + '*' + self.Lunits + '*' + self.Tunits + ")"if KEYWORD_SET(x_title) 	THEN xtitle=x_titleytitle = "Event Rate ((1/" + self.Lunits + ")(1/" + self.Tunits + "))"if KEYWORD_SET(y_title) THEN ytitle=y_titleymin = MIN(y, MAX=ymax)								; Get MIN and MAX of dependent variableyrange = [ymin, ymax]if KEYWORD_SET(y_range) THEN yrange=y_rangeGrid = {Grid}Grid.Mnemonic	= "Size"Grid.title		= xtitleGrid.units		= self.units + '*' + self.Lunits + '*' + self.TunitsGrid.values	= PTR_NEW(x)Grid.boundary	= 'open'Grid.uniform	= 0Grid.range		= xrangegrid.irange	= [0, N_elements(x)-1]result = {GKVs1D}result.mnemonic	= self.mnemonicresult.title	= titleindices = REPLICATE('*',1)result.indices	= PTR_NEW(indices)result.units	= "(1/" + self.Lunits + ")(1/" + self.Tunits + ")"result.values	= PTR_NEW(y)result.vrange	= yrangeresult.ErrorBars= PTR_NEW(pdf_error)result.CodeName	= self.CodeNameresult.CodePI	= self.CodePIresult.RunID	= self.RunIDresult.FileID	= self.FileIDresult.grid1	= GridRETURN, OBJ_NEW('GKVs1D', result)END ; ****** GKVpdf::GKVs1D ****** ;PRO GKVpdf::Draw, xrange=x_range, xstyle=x_style, title=T_title, xtitle=x_title,	$			  ytitle=y_title, yrange=y_range, ystyle=y_style, Pretty=pretty, 	$			  Exponent=alpha, PPDFs=ppdfs, xlog=x_log, ylog=y_log, _Extra=extra;; Form pdf from "Event_Vol" array (as returned by Event_Volume,; which is called by GKVpdf::Init), and plot result;FORWARD_FUNCTION PDFspdf = PDFs(	*self.strPtr, SIZES, PARTIAL_PDF=partial_pdf,		$	       	V_min=min_vol, Exponent=alpha, pdf_error=pdf_error	);; Normalize pdf;y  		= pdf/(self.Lx * self.T)x		=sizes*(self.dx)*(self.dt)pdf_error 	= pdf_error/(self.Lx * self.T)Partial_pdf= Partial_pdf/(self.Lx * self.T)ppdfInfo 	= SIZE(partial_pdf)Nppdfs	= ppdfInfo[2];; make plot;;; Use default plot keyword values from Object definition if they; are not over ridden on command line.;xmin = MIN(sizes, MAX=xmax)xrange=[xmin, xmax]if KEYWORD_SET(x_range) THEN xrange=x_rangetitle = 'PDF for events in ' + self.TitleIF KEYWORD_SET(T_title)	THEN title=T_titlexstyle=1IF(N_ELEMENTS(x_style) NE 0) THEN xstyle=x_stylex_title = 'Event Size (' + self.units + '*' + self.Lunits + '*' + self.Tunits + ")"if KEYWORD_SET(x_title) 	THEN xtitle=x_titleytitle = "Event Rate ((1/" + self.Lunits + ")(1/" + self.Tunits + "))"if KEYWORD_SET(y_title) THEN ytitle=y_titleymin = MIN(y, MAX=ymax)								; Get MIN and MAX of dependent variableyrange = [ymin, ymax]if KEYWORD_SET(y_range) THEN yrange=y_rangeystyle=1IF(N_ELEMENTS(y_style) NE 0) THEN ystyle=y_stylexlog=1IF(N_ELEMENTS(x_log) NE 0)	THEN xlog=x_logylog=1IF(N_ELEMENTS(y_log) NE 0) THEN ylog=y_logPLOT,	x, y, title=title, xlog=xlog, xrange=xrange, xstyle=xstyle,	$	; 	xtitle=xtitle, ytitle=ytitle, yrange=yrange, ylog=ylog, 		$	position=[0.15, 0.15, 0.9, 0.9], _Extra=extra ERRPLOT, x, y-pdf_error, y+pdf_errorOPLOT, x, y, psym=4OPLOT, x, Partial_pdf[*,0], Linestyle=5IF KEYWORD_SET(ppdfs) THEN	BEGIN	FOR i=1,Nppdfs-1 DO 	BEGIN		OPLOT, x, Partial_pdf[*,i], linestyle=2	ENDFORENDIF xwrite=!D.x_ch_size						; Device coordinates for writting toywrite=2.0*!D.y_ch_size					; lower left-hand corner of plot window.XYOUTS, xwrite, ywrite, self.CodeName, /Device	; Write CodeName to lower left-hand corner.ywrite=ywrite-1.5*!D.y_ch_size				; Move down 1.5 lines.XYOUTS, xwrite, ywrite, self.CodePI, /Device	; Write CodePI below CodeName.xwrite=!D.x_size -!D.x_ch_size				; Device coordinates for writting toywrite=2.0*!D.y_ch_size					; lower right-hand corner of plot window.XYOUTS, xwrite, ywrite, self.RunID,	$		 Alignment=1., /Device 			; Write RunID to lower right-hand corner.ywrite=ywrite-1.5*!D.y_ch_size				; Move down 1.5 lines.XYOUTS, xwrite, ywrite, self.FileID,	$ 		Alignment=1. , /Device			; write FileID to below RunIDEND ; ****** GKFpdf::Draw ****** ;FUNCTION GKVpdf::CleanUpPTR_FREE, self.ItemPtrPTR_FREE, self.NeventsPtrreturn, 1END ; ***** GKVpdf::CleanUp ***** ;FUNCTION GKVs2D::GKVpdf, Span=s, nScales=n_scales;; Purpose:;;		Computes Probability Distibution Function (PDF) for ;		pulse rate vs. pulse size from data in 'self'. ;		Takes a GKVs2D object as input, and produces a GKVpdf;		object as output.  ;; Arguments:;;			None;; Keywords:;;			None;; Written by W.M. Nevins;	9/28/00;result = OBJ_NEW('GKVpdf', self, span=s, nScales=n_scales)RETURN, resultEND ; ****** GKVs2D::GKVpdf ****** ;		FUNCTION GKVpdf::INIT, Obj, span=s, nScales=n_scales;; Preliminary init for testing object methods ...;Catch, error IF error NE 0 then Begin    Catch, /Cancel             ; Cancel error trap    ok=Error_Message(/Trace)   ; print out a trace-back in the output log    RETURN, 0                  ; Return 0 for unsuccessful call to INIT function. ENDIF ;; Check that argument is a GKVs2D object;IF(TypeOf(Obj) EQ 8) THEN BEGIN	nTags = N_TAGS(Obj)	pdfTags = N_TAGS({GKVpdf})	IF(nTags NE pdfTags) THEN BEGIN		MESSAGE, 'Called with bad argument', /INFORMATIONAL		RETURN, 0	ENDIF	FOR i=0, nTags-1 DO self.(i) = Obj.(i)	RETURN, 1ENDIFargClass = OBJ_CLASS(obj)IF (NOT STRCMP(argClass, 'GKVs2D', /FOLD_CASE) ) THEN BEGIN	MESSAGE, 'GKVpdf INIT only implimented for GKVs2D objects', /Informational	RETURN, 0ENDIF;; arrayPtr = Obj -> GetValues()FORWARD_FUNCTION Event_Volumeevent_vol = Event_Volume(*arrayPtr, FEATURES=features, span=s, nScales=n_scales, $		   		  MAPS=maps, RMS_ERRORS=rms_errors, MAX_ERRORS=max_errors);; Set tags for GKVsd class;	self.strPtr	= PTR_NEW(event_vol)	Obj -> GET, axis=1, irange=irange, gridValues=gridValues, GridUnits=self.Lunits		imin=irange[0]		imax=irange[1]		uniform = GKVsd_UniformGrid((*GridValues)[imin:imax])		IF(NOT uniform) THEN BEGIN			MESSAGE, 'WARNING: data may not be on a uniform grid', /Informational		ENDIF		self.dx = (*GridValues)[imin+1]	- (*GridValues)[imin]		self.Lx = (*GridValues)[imax] 	- (*GridValues)[imin]	Obj -> GET, axis=2, irange=irange, GridValues=GridValues, GridUnits=self.Tunits		imin=irange[0]		imax=irange[1]		uniform = GKVsd_UniformGrid((*GridValues)[imin:imax])		IF(NOT uniform) THEN BEGIN			MESSAGE, 'WARNING: data may not be on a uniform grid', /Informational		ENDIF		self.dt = (*GridValues)[imin+1]	- (*GridValues)[imin]		self.T  = (*GridValues)[imax] 	- (*GridValues)[imin]	Obj -> Get, mnemonic	= mnemonic,	$			 TItle	= Title,		$			 units	= units,		$			 CodePI 	=CodePI,		$			 RunID	= RunID,		$			 FileID	= FileID					self.mnemonic	= mnemonic		self.Title		= title		self.units		= units		self.CodePI	= CodePi		self.RunID		= RunID		self.FileID	= FileID		RETURN, 1END ; ****** GKVpdf::INIT ****** ;PRO GKVpdf__Definestruct = {	GKVpdf,				$	; GKV probability distribution function		strPtr		: PTR_NEW(),	$	; Pointer to Event_Vol structure		Lx		: 0.0,		$	; Spatial dimension (radial?) of input data		dx		: 0.0,		$	; Grid spacing		Lunits		: "",		$	; Spatial units		T		: 0.0,		$	; Temporal dimension of input data		dt		: 0.0,		$	; Size of time step		Tunits		: "",		$	; Temporal units		mnemonic	: "",		$	; Alpha/numeric mnemonic (as used in code)		Title		: "",		$	; "Pretty" name	(use IDL Vector Font)		units		: "",		$	; Units		(use IDL Vector Font)		CodeName	: "",		$	; Name of code which produced data		CodePI		: "",		$	; Name of PI (or team) responsible for code runs		RunID		: "",		$	; Run identifier		FileID		: ""			}	; Name of file from which data was extracted		END ; ****** GKVpdf__Define ****** ;