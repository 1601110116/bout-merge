function fields_to_frames, image   image_split, image, even, odd   image_size = size(image)   new_image = bytarr(image_size(1),image_size(2),2*image_size(3))   for i = 0, image_size(3)-1 do begin      new_image(*,*,2*i) = odd(*,*,i)      new_image(*,*,2*i+1) = even(*,*,i)   endfor   return, new_imageend;;;;;;;;;;;;;;;;;;pro get_xybion_data,shot=shot,matrox2=matrox2common output,a,shot_strcommon scale,r_pix,z_pix,time;keywords;shot		shot="a longword shot #" must be present, e.g. get_xybion_data,shot=1010622006;matrox2	set this keyword only if the data are stored on the matrox2 PC (rare), e.g.;			get_xybion_data,shot=1010622006,/matrox2print,systime(),"  :Getting Data"if not keyword_set(shot) then begin  mdsopen,'cmod,analysis',-1  shot = mdsvalue('current_shot("cmod")')endifshot_str=strtrim(shot,2)if keyword_set(matrox2) then begin    server='matrox2'    node = '\video::top:video:camera_1'  endif else begin    server='matrox3'    node = '\video::top:video:camera_1' endelse;print,server,nodemdsconnect,servermdsopen,'video',shotFORWARD_FUNCTION mdsvalueaa = mdsvalue(node,status=status)mdsdisconnect!mds_socket = -1print,systime(),"  :Data Retrieval - Done"print,systime(),"  :Converting Fields to Frames"if status then aa = fields_to_frames(aa) print,systime(),"  :Fields to Frames - Done"; Now we use subroutines to do the following:;               1) retrieve the position and;               rotation angle of the fiber-bundle "diamond" within the;               640x480 framegrabber frame. (subroutine read_tree_for_diamond_pos,;               shot_str,ang,rt_pix,lt_pix,top_pix,bot_pix);               2) (within the get_edge_video call) rotate the image;               CCW so that the diamond sides are vertical and;               horizontal, then cut the rotated image so only the diamond is left,;               then rescale the cut frame so that it is 303x304 pixels, then;               replace the resized image in a 640x480 black frame in the "calibration;               position", ie where lt_pix=163, rt_pix=466, bot_pix=133, and top_pix=435,;               and finally re-rotate the image CW by ang+2 degrees so that horizontal;               pixels are along Z=const planes and vertical pixels are along R=const;               planes. Finally the experimental frame is cut to get rid of that ;		part of the 640x480 frame which was outside the diamond boundaries. print,systime(),"  :Starting Diamond Rescale"; now find diamond positionshot_str=strtrim(shot,2)read_tree_for_diamond_pos,shot_str,ang,rt_pix,lt_pix,top_pix,bot_pix; now rotate, cut, rescale, replace, and re-rotatethet=180./!pi*atan(15./414.); this is the angle that the Z=const plane makes with the horizontal in an ; "almost-calibrated" frame. It is positive and CW. In order to make the ; experimental image have its horizontal pixels be along the Z=const plane, ; the image must be rotated CCW (i.e. -thet) by this amountn_frames=n_elements(aa(0,0,*))lt_cut=71rt_cut=490bot_cut=60top_cut=479; note the the frame size will now be 420x420a=bytarr((rt_cut-lt_cut+1),(top_cut-bot_cut+1),n_frames)for i=0,n_frames-1 do begin; rotate        aa(*,*,i)=TEMPORARY(rot(aa(*,*,i),ang)); cut        dum=aa(lt_pix:rt_pix,bot_pix:top_pix,i); rescale        dum=TEMPORARY(congrid(dum,304,303)); make new blank array        aa(*,*,i)=fltarr(640,480); replace        aa(165:468,133:435,i)=dum; re-rotate by 48+thet degrees        aa(*,*,i)=TEMPORARY(rot(aa(*,*,i),-(48.+thet)))	a(*,*,i)=TEMPORARY(aa(lt_cut:rt_cut,bot_cut:top_cut,i))endforprint,systime(),"  :Rescale - Done"find_dispersion_and_origin_rescale,ang,rt_pix,lt_pix,top_pix,bot_pix,disp,x_prime_origin,y_prime_originr_pix=891.0-(indgen(n_elements(a(*,0,0)))-x_prime_origin)/dispz_pix=-25.4+(indgen(n_elements(a(0,*,0)))-y_prime_origin)/disptime=(indgen(n_elements(a(0,0,*)))-2)*.016667print,systime(),"  :Spatial calibrations - Done"print,' 'print,' 'print,'The image data are in the array a (accessed by common output,a,shot_str)'print,'The R,Z location (in mm) of any pixel pair (i,j) are in the arrays r_pix,z_pix (accessed by common scale,r_pix,z_pix,time)'returnend;;;;;;;;;;;;;;;;PRO image_split, full_image, half_image1, half_image2   full_image_size = size(full_image)   if full_image_size(0) eq 3 then begin      n_frames = full_image_size(3)      half_image1 =  bytarr(640,480,n_frames)      half_image2 =  bytarr(640,480,n_frames)      j = indgen(240)      for k = 0, n_frames-1 do begin        half_image1(*,*,k) = rebin(full_image(*,j*2,k),640,480)        half_image2(*,*,k) = rebin(full_image(*,j*2+1,k),640,480)      endfor   endif else begin      half_image1 =  bytarr(640,480)      half_image2 =  bytarr(640,480)      FOR i=0,239 DO BEGIN         half_image1(*,i*2) =  full_image(*,i*2)         half_image2(*,i*2+1) =  full_image(*,i*2+1)      ENDFOR      FOR j= 1, 477, 2 DO BEGIN         half_image1(*,j) =  half_image1(*,j-1)/2 + half_image1(*,j+1)/2         half_image2(*,j+1) =  half_image2(*,j)/2 + half_image2(*,j+2)/2      ENDFOR   endelseEND;;;;;;;;;;;;;;;;;;;;;                  pro find_dispersion_and_origin_rescale,ang,rt_pix,lt_pix,top_pix,bot_pix,disp,x_prime_origin,y_prime_origindisp=1./0.187173; the disp (dispersion) is the number of pixels per mm. This was determined using; the template and the calibration frame (stored as E:/VIDEO/VIDEO_001.* on MATROX3; and as [terry.gpi]gpi_calib_frame.dat on the VAX). For a diamond size of (304(x) by; 303(y)) (where x is horizontal after rotating  ~48 degrees CW and y is vertical), the; dispersion is 1./0.187173 (see pages 47-48 in Terry MCP #6). Thus for a diamond size of ; p_x,p_y the dispersion is 1./0.187173*p_x/304.thet=0.; since in this version the x axis is aligned with Z=-25.4 mm plane and y is ; aligned with R=89.1 cm=const plane ; The origin of the coordinate system is (R,Z) = (891.0,-25.4) mm in; absolute space. This origin is in the position (178/304,173/303) in normalized; coordinates of the rotated diamond frame (i.e. after the frame has been rotated; CW by ang and then cut on its edges) of the calibration frame CALIB_FRAME_SCALED ; (which is stored in the IDL save set USER10:[TERRY.GPI]GPI_CALIB_FRAME.DAT). ; (This is a frame whose "position" in the original image (CALIB_FRAME_EXP) ; would be ang=48, LT_PIX=163, RT_PIX=466,BOT_PIX=133, TOP_PIX=435.)  ; Therefore the origin in the rotated and "cut" frame (in PIXELS ); for the diamond whose "position" coordinates were ang,rt_pix,lt_pix,top_pix,bot_pix is; (178/304.*(rt_pix-lt_pix),173/303.*(top_pix-bot_pix)). Since the diamond in this ; routine has already been scaled, the "origin" position coord. are (178,173) is the cut; and rescaled frame. This point was then translated when the diamond was put ; back in the calibration position within the 640x480 frame. That is, it was; translated by the calibration frame's lt_pix, bot_pix. thus is was ; (178+163,173+133)=(341,306). Then the frame and this point was rotated by ; thet_re_rotate=-(48.+180/!pi*atan(15./414.)) about the center of the 640x480 frame. This ; rotation transformed the origin point to the primed (re-rotated) frame ; as (x'-x_center)=(x-x_center)*cos(thet_re_rotate)+(y-y_center)*sin(thet_re_rotate) and ; (y'-y_center)=(y-y_center)*cos(thet_re_rotate)-(x-x_center)*sin(thet_re_rotate).; Thus the origin in the experimental, rescaled image is at ; x pixel=Xo*cos(ang)+Yo*sin(ang) and at ; y pixel=Yo*cos(ang)-Xo*sin(ang).X_o=341.Y_o=306.ang_cal=-(48.+180/!pi*atan(15./414.))x_prime_origin=(X_o-319.5)*cos(!pi/180.*ang_cal)+(Y_o-239.5)*sin(!pi/180.*ang_cal)+319.5y_prime_origin=(Y_o-239.5)*cos(!pi/180.*ang_cal)-(X_o-319.5)*sin(!pi/180.*ang_cal)+239.5lt_cut=71rt_cut=490bot_cut=60top_cut=479; Finally the experimental frame was cut to get rid of that part of the 640x480 frame; which was outside the diamond boundaries. Thus (lt_cut,bot_cut) is subtracted from; (x_prime_origin,y_prime_origin)x_prime_origin=x_prime_origin-lt_cuty_prime_origin=y_prime_origin-bot_cut ;print,' x_prime_origin,y_prime_origin=',x_prime_origin,y_prime_origin;stopreturnend;;;;;;;;;;;;;;pro read_tree_for_diamond_pos,shot_str,ang,rt_pix,lt_pix,top_pix,bot_pix	mdsopen,'spectroscopy',long(shot_str)	rt_pix=mdsvalue('\SPECTROSCOPY::TOP.GPI.IMAGE_POS:RT_PIX')	lt_pix=mdsvalue('\SPECTROSCOPY::TOP.GPI.IMAGE_POS:LT_PIX')	top_pix=mdsvalue('\SPECTROSCOPY::TOP.GPI.IMAGE_POS:TOP_PIX')	bot_pix=mdsvalue('\SPECTROSCOPY::TOP.GPI.IMAGE_POS:BOT_PIX')	ang=mdsvalue('\SPECTROSCOPY::TOP.GPI.IMAGE_POS:ROT_ANG')	mdsclosereturnend