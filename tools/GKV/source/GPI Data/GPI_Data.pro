PRO GKVs3D::GPINorm;; Purpose:;;		This proceedure END  ;  ****** GKVs3D::GPINorm ******  ;PRO GKVs3D::Window, dL=dLin, dN=dNin, Threshold=thresholdIn, TerryNorm=cnorm, NoAvg=noAvg;; Purpose:;		This routine applies a 'data window' to the data;		which (incompletely) fills the full range of the;		independent variables.;; Keywords:;;	dL		Set this keyword to the width (in the ;			same units as the independent variables) ;			of the data window.  Defaults to 1/10th ;			of the available range.  ;			(Optional);;	dN		Alternatively, set this keyword to the ;			(integer) width (in units of the increment;			between grid points of the independent ;			variables) of the data window.  ;			(Optional);;	Threshold	Set this keyword to the fraction of the ;			peak time-averaged signal which will define;			the edge of the window (that is, only the ;			spatial region in which the rms value of;			the dependent variable is larger than ;			Threshold*MaxAvgValue is retained within;			the data window).  Defaults to 0.1.;			(Optional);;	TerryNorm	Set this keyword (i.e., put '/TerryNorm on the ;			command line) to normalize dependent variable ;			such that avg value is constant within data;			window.  Default is no normalizatiion.;			(Optional);;	NoAvg		Set this keyword (i.e., put '/NoAvg';			on the command line) to subtract out the;			mean (that is, time average) value of the;			dependent variable at each pixel.;			Default is no subtraction of mean.;			(Optional);;; Written by W.M. Nevins;	12/6/01;; Set defaults, and get info from command line;FORWARD_FUNCTION GKVsd_MINiRange1 = self.Grid1.irangen1 = iRange1[1] - iRange1[0] + 1iRange2 = self.Grid2.irangen2 = iRange2[1] - iRange2[0] + 1nMax = n1 > n2dN = nMax/10 > 1IF(N_ELEMENTS(dNin) EQ 1) THEN dN=dNin > 1x1 = *self.Grid1.valuesL1  = x1[iRange1[1]]   - x1[iRange1[0]]dx1 = x1[iRange1[0]+1] - x1[iRange1[0]]x2 = *self.Grid2.valuesL2  = x2[iRange2[1]]   - x2[iRange2[0]]dx2 = x2[iRange2[0]+1] - x2[iRange2[0]]dxMin = dx1 < dx2IF(N_ELEMENTS(dL) EQ 1) THEN dN = FIX(dL/dxMin) > 1threshold=0.1IF(N_ELEMENTS(thresholdIn) EQ 1) THEN threshold=thresholdIn;; Construct mask which encloses all non-zero data; (1 where there is data, 0 where there is not data);iRanget = self.Grid3.irangeit0  = iRanget[0]itmin= iRanget[0] + 1itmax= iRanget[1]nt = itmax - it0 + 1values = *self.valuesvalues = FLOAT(values)avgValue    = TOTAL(values,3)/ntmaxAvgValue = MAX(avgValue);valuesSq = values*values;avgValueSq = TOTAL(valuesSq,3);maxAvgValueSq = MAX(avgVAlueSq)Norm = SQRT(avgValue/maxAvgValue)mask = Norm GT thresholdNorm = Norm > thresholdIF KEYWORD_SET(NoAvg)     THEN FOR it=it0, itmax DO values[*,*,it] = values[*,*,it] - avgValueIF KEYWORD_SET(TerryNorm) THEN FOR it=it0, itmax DO values[*,*,it] = values[*,*,it]/Norm;; Construct array (of length dN) of masks; in which we strip off boundary points at each level;vInfo = SIZE(mask)mask[0, *] = 0mask[vInfo[1]-1, *] = 0mask[*, 0] = 0mask[*, vInfo[2]-1] = 0masks = BYTARR(vInfo[1], vInfo[2], dN+1)masks[*,*,0] = maskFOR n=1,dN DO BEGIN	FOR i=-1,1 DO BEGIN		FOR j=-1,1 DO BEGIN			masks[*,*,n] = masks[*,*,n] + SHIFT(masks[*,*,n-1], i, j) 		ENDFOR	ENDFOR	masks[*,*,n] = masks[*,*,n] EQ 9ENDFOR;; Form window which is linear ramp from 0 (region with no data) ; to 1 (region in which data is to be left unaltered);window = TOTAL(masks,3)/FLOAT(dN+1);; Turn this into 0.5*(1-cos) window (Hanning form);window = 0.5*(1.0 - COS(!PI*window));; Apply window to dependent variable;FOR it=it0, itmax DO values[*,*,it] = window*values[*,*,it];; Replace values of dependent variable in 'self' with; 'windowed' values.;PTR_FREE, self.valuesself.values = PTR_NEW(values) vmin = GKVsd_MIN(values, MAX=vmax)self.vrange=[vmin, vmax];; ... and we're done;RETURNEND  ;  ****** GKVs3D::Window ******  ;FUNCTION GPI_Data, 	GetFile=GetFile, ShotNumber=shot_Number,$			Tiff=tiff, dataType=data_type,		$			ASCII=ascii_dims, 			$			dz=d_z, dr=d_r, dt=d_t, 		$						Path=path, File=filein,			$			CodeName=Code_Name, CodePI=Code_PI, 	$			FileID=File_ID, RunID=Run_ID, 		$			Title=titleIn, Mnemonic=mnemonicIn,	$			nFiles=nFilesIn, Extension=extensionIn,	$			Units=unitsIn, DeBug=debug;; Purpose:;;		This routine reads GPI data from IDL save files and;		returns it in the form of a GKV object;; Keywords:;;	GetFile		Set this keyword (i.e., put "/GetFile" on the command line);			to read data from an IDL SAVE file.  Default is to get;			data from MDS PLUS system (which will only work on MIT;			VAX cluster). (Optional)  ;;	ShotNumber	Set this keyword the INTEGER value of;			the C-Mod shot number.;			The format of the shot number is '1yymmddsss',;			where yy is the year, mm is the month, ;			dd is the day, and sss is the shot number ;			within that day.  This must be provided if;			you are attempting to access data directly from;			the MDS PLUS system (that is, if the keyword;			'GetFile' is set).  Otherwise setting the ;			ShotNumber is optional.  Defaults;			to 1010622006. (Optional);;	Path		Set this keyword to a STRING variable containing;			the path to the directory in which you wish to;			begin your search for the IDL SAVE file containing;			the GPI data.  This varialbe is only used when the;			keyword 'GetFile' is set.  Defaults to the current;			directory.  (Optional);;	File		Set this keyword to a STRING variable containing;			the FULL designation of the IDL SAVE file containing;			the GPI data.  If this keyword is not set (and 'GetFile';			IS set) then a pop-up widget will appear to allow the;			user to select the appropriate file. ;;			OR, if data is in a sequence of 'TIFF' files, set this;			keyword to a STRING varialbe containing the FULL;			designation of the first file in this sequence.  ;			(Optional);;	nFiles		Set this keyword to the (integer) number of 'TIFF';			files in the file sequence.  ;			Defaults to 99  (optional).;;	extension	Set this keyword to the (string) extension of the;			'TIFF' files.  Defaults to 'tif'.  Note that ;			case matters here!;;	CodeName	Set this keyword to a STRING variable containing;			the desired contents of the 'CodeName' field which;			will appear in the lower left-hand corner of plots.;			Defaults to 'C-Mod GPI Data'. (Optional);;	CodePI		Set this keyword to a STRING variable containing ;			the desired contents of the 'CodePI' field which;			will appear in the lower left-hand corner of plots.;			Defaluts to 'Jim Terry'. (Optional);;	RunId		Set this keyword to a STRING variable containing;			the desired contents of the 'FileID' field which;			will appear in the lower right-hand corner of plots.;			Defaults to 'Shot Number'. (Optional);			(Optional);;	FileId		Set this keyword to a STRING variable containing;			the desired contents of the 'RunID' field which;			will appear in the lower right-hand corner of plots.;			Defaults to a STRING variable containing the ascii;			representation of 'ShotNumber' (see above).;;	Title		Set this keyword to a STRING variable containing;			the desired contents of the 'Title' field which;			will appear above "Pretty" plots.;			Defaults to 'GPI'. (Optional);;	Mnemonic	Set this keyword to a STRING variable containing;			the desired contents of the 'Mnemonic' field which;			will appear in above default plots, and is used as;			a default name when saving data.;			Defaults to 'GPI'. (Optional);;	Units		Set this keyword to a STRING variable containing;			the desired contents of the 'Units' field which;			will appear above plots.;			Defaults to 'Arbitrary Units'. (Optional);;	DeBug		Set this keyword (i.e., put '/DeBug' on the ;			command line) to have IDL print additional;			information which may (or may not ...) be;			helpful in debugging.  (Optional);; Written by W.M. Nevins;	12/5/01;; Get 'ShotNumber';ShotNumber = 1010622006IF(N_ELEMENTS(shot_number) GT 0) THEN BEGIN	IF(Query_Integer(shot_Number)) THEN ShotNumber=shot_number	IF( Query_String(shot_number)) THEN ShotNumber=LONG(shot_number)ENDIF;; Get GPI data, and load into 'output' and 'scale' common blocks;CD, current=currentWorkingDirectoryistiff=0IF(N_ELEMENTS(fileIn)) THEN isTiff = QUERY_TIFF(fileIn, fileInfo);; check if user is looking for a gkv save file;IF ( KEYWORD_SET(GetFile) OR KEYWORD_SET(FileIn) ) THEN BEGIN	;	; Get data from IDL SAVE file	;	separator='/'	IF(!D.NAME EQ 'MAC') THEN separator=':'	IF(!D.NAME EQ 'WIN') THEN separator='\'	;	; NOTE:	THIS IS NOT GOING TO WORK ON A VAX!  	; 	There is no way to set the directory-	;	separator character correctly.	;	; Check for 'path'	;	IF(N_ELEMENTS(path) NE 0 ) THEN BEGIN		IF(TypeOf(Path) EQ 7) THEN CD, path	ENDIF	;	; Check for input file, 'FileIn'	;	IF( (N_Elements(FileIn) EQ 0) OR (TypeOf(FileIn) NE 7) ) THEN BEGIN		; 		; Use pop-up widget to select input file		;		FileIn=DIALOG_PICKFILE(FILTER='*.dat')		IF(FileIn EQ '') THEN BEGIN			;			; User failed to properly select an input file			;			MESSAGE, "No input file was selected -- Returning", /INFORMATIONAL			CD, currentWorkingDirectory			RETURN, 0		ENDIF		ENDIF 	;	; Assume that we now have	; an input file, and restore 	; the data from it!	;	RESTORE, FileIn, VERBOSE=debug	GOTO, GOT_DATAENDIF IF ( KEYWORD_SET(tiff) OR isTiff) THEN BEGIN	;	; Get data from TIFF file	;	separator='/'	IF(!D.NAME EQ 'MAC') THEN separator=':'	IF(!D.NAME EQ 'WIN') THEN separator='\'	;	; NOTE:	THIS IS NOT GOING TO WORK ON A VAX!  	; 	There is no way to set the directory-	;	separator character correctly.	;	; Check for 'path'	;	IF(N_ELEMENTS(path) NE 0 ) THEN BEGIN		IF(TypeOf(Path) EQ 7) THEN CD, path	ENDIF	IF( NOT isTiff) THEN BEGIN		FileIn=DIALOG_PICKFILE(FILTER='*.tif')		IF(FileIn EQ '') THEN BEGIN			;			; User failed to properly select an input file			;			MESSAGE, "No data file was selected -- Returning", /INFORMATIONAL			CD, currentWorkingDirectory			RETURN, 0		ENDIF		isTiff = QUERY_TIFF(fileIn, fileInfo)		IF(isTiff EQ 0) THEN BEGIN			;			; User failed to select a '*.tif' file			;			MESSAGE, "This is not a TIFF file  -- Returning", /INFORMATIONAL			CD, currentWorkingDirectory			RETURN, 0		ENDIF			ENDIF	;	; Assume that we now have	; an input '*.tif' file, and extract 	; the data from it!	;	nSlices = 99	IF QUERY_INTEGER(nFilesIn) THEN nSlices = nFilesIn > 2	nSlices = nSlices < 99	nx = fileInfo.DIMENSIONS[1]	ny = fileInfo.DIMENSIONS[0]	dataType = fileInfo.PIXEL_TYPE	IF(N_ELEMENTS(data_type) EQ 1) THEN dataType=data_type	a = MAKE_ARRAY(nx, ny, nSlices>2, TYPE=dataType)	;	; Remove 'path', extension from FileIn	;	fileName = GTC_FILENAME(FileIn)	;	; Remove sequence Number	;	subStrings = STRSPLIT(fileName, '_', /Extract)	nStrings = N_ELEMENTS(SubStrings)	fileRoot = subStrings[0]	IF(nStrings GT 2) THEN FOR iString=1, nStrings-2 DO fileRoot = fileRoot + subStrings[i]	sequenceLength = STRLEN(subStrings[nStrings-1])	firstSequenceNumber = FIX(subStrings[nStrings-1])	extension = 'tif'	IF(Query_String(extensionIn)) THEN extension=extensionIn		mincnt=15000	maxcnt=100		FOR iSlice=0,nSlices-1 DO BEGIN		sequenceNumber = STRING(firstSequenceNumber + iSlice)		sequenceNumber = STRCOMPRESS(sequenceNumber, /REMOVE_ALL)		WHILE STRLEN(sequenceNumber) LT sequenceLength DO sequenceNumber = '0' + sequenceNumber	 	thisFile = fileRoot + '_' + sequenceNumber + '.' + extension	 	IF( NOT QUERY_TIFF(thisFile) ) THEN GOTO, LastFile		a[*,*,iSlice]=REVERSE( TRANSPOSE( READ_TIFF(thisFile) ), 2 ) ; , IMAGE_INDEX=0, CHANNELS=0		histo = HISTOGRAM(a[*,*,iSlice], min=100, max=15000)		idx = WHERE(histo GE 30)			; Number to play with		n = N_ELEMENTS(idx)		cntmin = idx[0] + 100		IF(cntmin LE mincnt) THEN mincnt = cntmin		cntmax = idx[n-1]		IF(cntmax GE maxcnt) THEN maxcnt = cntmax	ENDFOR	iSlice = nSlicesLastFile : iSlice = iSlice-1	IF( iSlice LT (nSlices-1) ) THEN BEGIN		a=a(*,*,0:iSlice)		nSlices = iSlice + 1	ENDIF		IF(nSlices EQ 1) THEN BEGIN		a[*,*,1] = a[*,*,0]		iSlice = 2	ENDIF	minMax = [mincnt, maxcnt]	;	; get display range	;	;******** HOW TO GET r_pix, z_pix, and time ??? ***********	r_pix = FINDGEN(nx) - FLOAT(nx-1)/2.	z_pix = FINDGEN(ny) - FLOAT(ny-1)/2.	time = FINDGEN(nSlices>2)	IF(NOT Query_String(Code_Name)) THEN Code_Name = 'NSTX GPI Data'	IF(NOT Query_String(Code_PI  )) THEN Code_PI = 'S. Zweben and A. Keesee'ENDIF ELSE BEGIN	;	; Assume that files are ASCII files	;	; Check if ASCII information has been	; supplied on the command line.	;	nx=81	ny=161	IF(N_ELEMENTS(ascii_dims) EQ 2) THEN BEGIN		nx=ascii_dims[0]		ny=ascii_dims[1]	ENDIF	;	; Get data from ASCII file	;	separator='/'	IF(!D.NAME EQ 'MAC') THEN separator=':'	IF(!D.NAME EQ 'WIN') THEN separator='\'	;	; NOTE:	THIS IS NOT GOING TO WORK ON A VAX!  	; 	There is no way to set the directory-	;	separator character correctly.	;	; Check for 'path'	;	IF(N_ELEMENTS(path) NE 0 ) THEN BEGIN		IF(TypeOf(Path) EQ 7) THEN CD, path	ENDIF	FileIn=DIALOG_PICKFILE(FILTER='*.doc')	IF(FileIn EQ '') THEN BEGIN		;		; User failed to properly select an input file		;		MESSAGE, "No data file was selected -- Returning", /INFORMATIONAL		CD, currentWorkingDirectory		RETURN, 0	ENDIF	;	; Assume that we now have	; the first of a sequence 	; of  '*.doc' files	;	nSlices = 99	IF QUERY_INTEGER(nFilesIn) THEN nSlices = nFilesIn > 2	nSlices = nSlices < 99	dataType = 4 ; default to floating point	IF(N_ELEMENTS(data_type) EQ 1) THEN dataType=data_type	a = MAKE_ARRAY(nx, ny, nSlices>2, TYPE=dataType)	aa = MAKE_ARRAY(nx, ny, TYPE=dataType)	;	; Remove 'path', extension from FileIn	;	fileName = GTC_FILENAME(FileIn)	;	; Remove sequence Number	;	subStrings = STRSPLIT(fileName, '_', /Extract)	nStrings = N_ELEMENTS(SubStrings)	fileRoot = subStrings[0]	IF(nStrings GT 2) THEN FOR iString=1, nStrings-2 DO fileRoot = fileRoot + subStrings[i]	sequenceLength = STRLEN(subStrings[nStrings-1])	firstSequenceNumber = FIX(subStrings[nStrings-1])	extension = 'doc'	IF(Query_String(extensionIn)) THEN extension=extensionIn		mincnt=15000	maxcnt=100	GET_LUN, IO_Unit		FOR iSlice=0,nSlices-1 DO BEGIN		sequenceNumber = STRING(firstSequenceNumber + iSlice)		sequenceNumber = STRCOMPRESS(sequenceNumber, /REMOVE_ALL)		WHILE STRLEN(sequenceNumber) LT sequenceLength DO sequenceNumber = '0' + sequenceNumber	 	thisFile = fileRoot + '_' + sequenceNumber + '.' + extension	 	IF( NOT FILE_TEST(thisFile, /READ, /REGULAR) ) THEN GOTO, LastAsciiFile	 	OPENR, IO_Unit, thisfile		READF, IO_Unit, aa		a[*,*,iSlice] = aa		CLOSE, IO_Unit		histo = HISTOGRAM(aa, min=100, max=15000)		idx = WHERE(histo GE 30)			; Number to play with		n = N_ELEMENTS(idx)		cntmin = idx[0] + 100		IF(cntmin LE mincnt) THEN mincnt = cntmin		cntmax = idx[n-1]		a[*,*,iSlice] = aa		IF(cntmax GE maxcnt) THEN maxcnt = cntmax	ENDFOR	iSlice = nSlicesLastAsciiFile : iSlice = iSlice-1	IF( iSlice LT (nSlices-1) ) THEN BEGIN		a=a(*,*,0:iSlice)		nSlices = iSlice + 1	ENDIF		FREE_LUN, IO_Unit		IF(nSlices EQ 1) THEN BEGIN		a[*,*,1] = a[*,*,0]		iSlice = 2	ENDIF	minMax = [mincnt, maxcnt]	;	; get display range	;	;******** HOW TO GET r_pix, z_pix, and time ??? ***********	r_pix = FINDGEN(nx) - FLOAT(nx-1)/2.	z_pix = FINDGEN(ny) - FLOAT(ny-1)/2.	time = FINDGEN(nSlices>2)	IF(NOT Query_String(Code_Name)) THEN Code_Name = 'NSTX GPI Data'	IF(NOT Query_String(Code_PI  )) THEN Code_PI = 'S. Zweben and A. Keesee'ENDELSEGOT_DATA	: CD, currentWorkingDirectoryaInfo = SIZE(a);; Set up Grid structures for the three independent variables;nRs = N_ELEMENTS(r_pix)IF(nRs NE aInfo[1]) THEN MESSAGE, 'Bad R-Dimension to a-array.  Coming to a crashing halt!', /INFORMATIONALIF(r_pix[0] GT r_pix[nRs-1]) THEN BEGIN	;	; Array has r's in DECREASING order.  Fix this!	;	r_pix = REVERSE(r_pix)	a = REVERSE(a, 1)ENDIFdr=1.IF(N_ELEMENTS(d_r) EQ 1) THEN dr=d_rr_pix =dr* r_pix	; Convert unitsrmin = r_pix[0]rmax = r_pix[nRs-1]iRmin = 0iRmax = nRs-1rGrid = {Grid}	rGrid.Mnemonic	= 'R'	rGrid.title	= 'R'	rGrid.units	= 'cm'	rGrid.values	= PTR_NEW(r_pix)	rGrid.boundary	= 'open'	rGrid.range	= [rmin, rmax]	rGrid.irange	= [iRmin, iRmax]	nZs = N_ELEMENTS(z_pix)IF(nZs NE aInfo[2]) THEN MESSAGE, 'Bad Z-Dimension to a-array.  Coming to a crashing halt!', /INFORMATIONALIF(z_pix[0] GT z_pix[nZs-1]) THEN BEGIN	;	; Array has z's in DECREASING order.  Fix this!	;	z_pix = REVERSE(z_pix)	a = REVERSE(a, 2)ENDIFdz = 1.IF(N_ELEMENTS(d_z) EQ 1) THEN dz = d_zz_pix = dz*z_pix	; Convert unitszmin = z_pix[0]zmax = z_pix[nZs-1]iZmin = 0iZmax = nZs-1zGrid = {Grid}	zGrid.Mnemonic	= 'Z'	zGrid.title	= 'Z'	zGrid.units	= 'cm'	zGrid.values	= PTR_NEW(z_pix)	zGrid.boundary	= 'open'	zGrid.range	= [zmin, zmax]	zGrid.irange	= [iZmin, iZmax]nTs = N_ELEMENTS(time)IF(nTs NE aInfo[3]) THEN MESSAGE, 'Bad t-Dimension to a-array.  Coming to a crashing halt!', /INFORMATIONALIF(time[0] GT time[nTs-1]) THEN BEGIN	;	; Array has t's in DECREASING order.  Fix this!	;	time = REVERSE(time)	a = REVERSE(a, 3)ENDIFdt=1.IF(N_ELEMENTS(d_t) EQ 1) THEN dt=d_ttime = dt*timetmin = time[0]tmax = time[nTs-1]itmin = 0itmax = nTs-1tGrid = {Grid}	tGrid.Mnemonic	= 't'	tGrid.title	= 't'	tGrid.units	= 's'	tGrid.values	= PTR_NEW(time)	tGrid.boundary	= 'open'	tGrid.range	= [tmin, tmax]	tGrid.irange	= [itmin, itmax];;  Check for info from command line;mnemonic = 'GPI'IF(Query_String(mnemonicIn)) THEN mnemonic=mnemonicIntitle = 'GPI'IF(Query_String(titleIn)   ) THEN title=titleInCodeName = 'C-Mod GPI Data'IF(Query_String(Code_Name) ) THEN CodeName=Code_NameCodePI = 'Jim Terry'IF(Query_String(Code_PI)   ) THEN CodePI = Code_PIRunID = 'Shot Number'IF(Query_String(Run_ID)    ) THEN RunID = Run_IDFileID = ''IF(N_ELEMENTS(Shot_str) NE 0) THEN FileID = shot_strIF(Query_String(File_ID)    ) THEN FileID = File_IDIF(Query_Integer(File_ID)   ) THEN FileID = STRCOMPRESS(STRING(File_ID), /REMOVE_ALL)Units = 'Arbitrary Units'IF(Query_Integer(UnitsIn)  ) THEN Units = unitsINindices = REPLICATE('*', 3)IF(N_ELEMENTS(minmax) EQ 2) THEN BEGIN	vmin = minMax[0]	vmax = minMax[1]ENDIF ELSE BEGIN	vmin = GKVsd_MIN(a, MAX=vmax)ENDELSE;; Now set up GKVs3D structure ;GPIstr = {GKVs3D}	GPIstr.mnemonic = mnemonic	GPIstr.title	= title	GPIstr.Indices	= PTR_NEW(indices)	GPIstr.units	= units	GPIstr.values	= PTR_NEW(FLOAT(a))	GPIstr.vrange	= [vmin, vmax]	GPIstr.CodeName	= CodeName	GPIstr.CodePI	= CodePi	GPIstr.RunID	= RunID	GPIstr.FileId	= FileID	GPIstr.Grid1	= rGrid	GPIstr.Grid2	= zGrid	GPIStr.Grid3	= tGrid;; Create GPI object;GPIobj = OBJ_NEW('GKVs3D', GPIstr)	RETURN, GPIobjEND	; ****** GPI_Data ****** ;