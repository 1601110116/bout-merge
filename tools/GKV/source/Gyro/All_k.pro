PRO GKVs1D::All_k, arg, _Extra=extra;; Purpose:;;	This proceedure expects that 'self' contains the non-negative ;	Fourier coefficients (vs. the independent variable 'arg') ;	from a real data series.  On return, 'self' contains a full;	set of Fourier coefficeints, where the coefficeints for;	negative values of 'arg' are formed by taking the complex;	conjugate of those at positive values of 'arg'.;; Arguments:;;	arg	A valid axis ID.  That is, the axis number or any;		valid axis mnemonic. Defaults to axis 1.  (Optional);;; Keywords:;; 'mnemonic'	Alternatively, the independent variable labeling the ;		Fourier coefficeints can be spectified in the form;		'mnemonic'=value, where 'mnemonic is a valid axis;		mnemonic, and value is the maximum absolute value of ;		this variable to be retained on return.  If 'value';		is greater than the maximum value of this index, then;		the additional Fourier coefficeints will be set to zero.;		(Optional).;;     kmax	Set this keyword equal to the maximum absolute value of the;		Fourier transformed variable desired in 'self' on return.;;     NoAvg	Set this keyword (i.e., put '/NoAvg' on the command line);		to remove the k=0 component of the Fourier transformed signal.;;  NoNegative	Set this keyword (i.e., put '/NoNegative' on the command line);		to put zeros in the negative 'n' components.  Default is to;		put the complex conjugate of the positive components in the ;		negative 'n' components. (Optional).;;; Written by W.M. Nevins;	2/13/02;nDims = self -> NumDims()IF(nDims LT 1) THEN BEGIN	MESSAGE, 'All_k called on object of less than 1 dimension, Returning', /INFORMATIONAL	RETURNENDIF;; Save copy of 'extra';IF(TypeOF(extra) NE 0) THEN nExtra=extra;; Find axis identifier;CASE N_PARAMS() OF	0	:	iAxis = self -> AxisIrange(     _Extra=extra)	1	:	iAxis = self -> AxisIrange(arg, _Extra=extra)	else	:	BEGIN				MESSAGE, 'All_k called with too many arguments', /INFORMATIONAL				RETURN			ENDENDCASEIF(iAxis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier, will act on axis 1', /INFORMATIONAL	iAxis = 1	; default axis valueENDIFself -> Restrict;; Get Grid structure of Independent Fourier variable,; and store in 'kGrid';gridString = 'Grid' + STRCOMPRESS(STRING(iAxis), /REMOVE_ALL)commandString = 'kGrid = self.' + gridStringOK = EXECUTE(commandString);; Check for negative values of independent Fourier variable;kmin = kGrid.range[0]IF(kmin LT 0) THEN BEGIN	MESSAGE, 'All_k called with negative values of independent Fourier variable, returning with no action', /INFORMATIONALENDIF;; Check that kGrid is uniform;uniform = GKVsd_UniformGrid(kGrid)IF(NOT uniform) THEN BEGIN	MESSAGE, 'All_k called on non-uniform indpendent variable, returning with no action', /INFORMATIONAL	RETURNENDIF;; Get kmax;kmax = kGrid.range[1]		; set default;; Check for 'kmax=value' on command line;result = GetKeyWord('kmax', Extra)IF(Query_Real(result) OR Query_Integer(result)) THEN kmax=FLOAT(result);; Check for 'mnemonic'=value on command line;gridMnemonic = kGrid.mnemonicresult = GetKeyWord(gridMnemonic, nExtra)IF(Query_Real(result) OR Query_Integer(result)) THEN kmax=FLOAT(result);; Generate new kGrid values;oldKs = *kGrid.valuesdK = oldKs[1] - oldKs[0]nKs = 2*FIX(kmax/dk) + 1newKs = -kmax + dK*FINDGEN(nKs);; Create new grid structure which includes negative values of independent Fourier variable;newGrid=kGridnewGrid.values = PTR_NEW(newks)newGrid.irange = [0,nKs-1]newGrid.range = [-kmax,kmax]newGrid.boundary = "periodic (closed)"newGrid.uniform = 1b;; Generate indices into new and old values arrays;iMin = nKs/2 + FIX(kmin/dk)iMax = nKs/2 + kGrid.irange[1] + FIX(kmin/dk)IF( iMax GT (nKs-1) ) THEN BEGIN	DiMax = iMax - (nKs-1)	kGrid.irange[1] = kGrid.irange[1] - DiMax	iMax = nKs-1ENDIFoldMin = kGrid.irange[0]oldMax = kGrid.irange[1];; Create newValues array;oldValues = *self.valuesinfo = SIZE(oldValues)nMax = LONARR(nDIms+1)nMax[1:nDims] = info[1:nDims]CASE nDims OF	1:	newValues = COMPLEXARR(nKs)	2:	CASE iAxis OF			1:	newValues = COMPLEXARR(    nKs, nMax[2])			2:	newValues = COMPLEXARR(nMax[1],     nKs)		ENDCASE	3:	CASE iAxis OF			1:	newValues = COMPLEXARR(    nKs, nMax[2], nMax[3])			2:	newValues = COMPLEXARR(nMax[1],     nKs, nMax[3])			3:	newValues = COMPLEXARR(nMax[1], nMax[2],     nKs)		ENDCASE	4:	CASE iAxis OF			1:	newValues = COMPLEXARR(    nKs, nMax[2], nMax[3], nMax[4])			2:	newValues = COMPLEXARR(nMax[1],     nKs, nMax[3], nMax[4])			3:	newValues = COMPLEXARR(nMax[1], nMax[2],     nKs, nMax[4])			4:	newValues = COMPLEXARR(nMax[1], nMax[2], nMax[3],     nKs)		ENDCASEENDCASE;; Load oldvalues into this new array;CASE nDims OF	1:	newValues[iMin:iMax] = oldValues[oldMin:oldMax]	2:	CASE iAxis OF			1:	newValues[iMin:iMax, *] = oldValues[oldMin:oldMax,             *]			2:	newValues[*, iMin:iMax] = oldValues[            *, oldMin:oldMax]		ENDCASE	3:	CASE iAxis OF			1:	newValues[iMin:iMax, *, *] = oldValues[oldMin:oldMax,              *,             *]			2:	newValues[*, iMin:iMax, *] = oldValues[             *, oldMin:oldMax,             *]			3:	newValues[*, *, iMin:iMax] = oldValues[             *,             *, oldMin:oldMax]		ENDCASE	4:	CASE iAxis OF			1:	newValues[iMin:iMax, *, *, *] = oldValues[oldMin:oldMax,              *,             *,             *]			2:	newValues[*, iMin:iMax, *, *] = oldValues[             *, oldMin:oldMax,             *,             *]			3:	newValues[*, *, iMin:iMax, *] = oldValues[             *,             *, oldMin:oldMax,             *]			4:	newValues[*, *, *, iMin:iMax] = oldValues[             *,             *,             *, oldMin:oldMax]		ENDCASEENDCASE;; Then complex conjugate of oldValues into negative Fourier harmonics;result = GetKeyWord('NoNegative', Extra)IF( (TypeOf(result) NE 7) AND (KEYWORD_SET(result)) ) THEN GOTO, NoNegativeNsCASE nDims OF	1:	newValues[0:(nKs/2-1)] = REVERSE(CONJ(newValues[(nKs/2+1):(nKs-1)]))	2:	CASE iAxis OF			1:	newValues[0:(nKs/2-1), *] = REVERSE(CONJ(newValues[(nKs/2+1):(nKs-1), *]), 1)			2:	newValues[*, 0:(nKs/2-1)] = REVERSE(CONJ(newValues[*, (nKs/2+1):(nKs-1)]), 2)		ENDCASE	3:	CASE iAxis OF			1:	newValues[0:(nKs/2-1), *, *] = REVERSE(CONJ(newValues[(nKs/2+1):(nKs-1), *, *]), 1)			2:	newValues[*, 0:(nKs/2-1), *] = REVERSE(CONJ(newValues[*, (nKs/2+1):(nKs-1), *]), 2)			3:	newValues[*, *, 0:(nKs/2-1)] = REVERSE(CONJ(newValues[*, *, (nKs/2+1):(nKs-1)]), 3)		ENDCASE	4:	CASE iAxis OF			1:	newValues[0:(nKs/2-1), *, *, *] = REVERSE(CONJ(newValues[(nKs/2+1):(nKs-1), *, *, *]), 1)			2:	newValues[*, 0:(nKs/2-1), *, *] = REVERSE(CONJ(newValues[*, (nKs/2+1):(nKs-1), *, *]), 2)			3:	newValues[*, *, 0:(nKs/2-1), *] = REVERSE(CONJ(newValues[*, *, (nKs/2+1):(nKs-1), *]), 3)			4:	newValues[*, *, *, 0:(nKs/2-1)] = REVERSE(CONJ(newValues[*, *, *, (nKs/2+1):(nKs-1)]), 4)		ENDCASEENDCASENoNegativeNs	:;; check for 'NoAvg keyword;result = GetKeyWord('NoAvg', Extra)IF( (TypeOf(result) NE 7) AND KEYWORD_SET(result) ) THEN BEGINCASE nDims OF	1:	newValues[nKs/2] = 0.	2:	CASE iAxis OF			1:	newValues[nKs/2, *] = COMPLEXARR(nMax[2])			2:	newValues[*, nKs/2] = COMPLEXARR(nMax[1])		ENDCASE	3:	CASE iAxis OF			1:	newValues[nKs/2, *, *] = COMPLEXARR(nMax[2], nMax[3])			2:	newValues[*, nKs/2, *] = COMPLEXARR(nMax[1], nMax[3])			3:	newValues[*, *, nKs/2] = COMPLEXARR(nMax[1], nMax[2])		ENDCASE	4:	CASE iAxis OF			1:	newValues[nKs/2, *, *, *] = COMPLEXARR(nMax[2], nMax[3], nMax[4])			2:	newValues[*, nKs/2, *, *] = COMPLEXARR(nMax[1], nMax[3], nMax[4])			3:	newValues[*, *, nKs/2, *] = COMPLEXARR(nMax[1], nMax[2], nMax[4])			4:	newValues[*, *, *, nKs/2] = COMPLEXARR(nMax[1], nMax[2], nMax[3])		ENDCASEENDCASEENDIF;; load new grid and new values into 'self';commandString = 'self.' + GridString + ' = newGrid'OK = EXECUTE(commandString)PTR_FREE, kGrid.valuesPTR_FREE, self.valuesself.values = PTR_NEW(newValues)RETURNEND  ;  ****** All_k ******  ;FUNCTION GKVs1D::All_k, arg, _extra=extracopy = self -> makeCopy()nArgs = N_PARAMS()CASE nArgs OF	0:	copy -> all_K, _Extra=Extra	1:	copy -> all_k, arg, _extra=extra	ELSE:	BEGIN			MESSAGE, "All_k Called with too many arguments, Returning", /INFORMATIONAL			RETURN, 0		ENDELSEENDCASEreturn, copyend