FORWARD_FUNCTION GKVsd_MINPRO GKVs1D::Repair;; Purpose;;		This proceedure repairs removes 'holes';		in the time-sequence of 'self' that may;		result from bad restarts of pg3eq.;; Written by W.M. Nevins;	10/2/00;oldTimeSeries = *self.Grid1.valuesoldNT = N_ELEMENTS(oldTimeSeries)errors = PTR_VALID(self.ErrorBars);; Find 'holes' in old time series;inHole=0bstartHole = 0endHole   = 0lastT = oldTimeSeries[0]FOR i=1, oldNT-1 DO BEGIN	IF(oldTimeSeries[i] GT lastT) THEN BEGIN		IF(inHole) THEN BEGIN			IF((oldTImeSeries[i] - lastT) GT 10*dt) THEN GOTO, doneThis			endHole = [endHole, i]			inHole = 0b		ENDIF		dT = oldTimeSeries[i] - lastT		lastT = oldTimeSeries[i]	doneThis:	ENDIF ELSE BEGIN		IF( NOT inHole) THEN BEGIN			startHole = [startHole, i]			inHole = 1b		ENDIF			ENDELSEENDFOR;; Check if we found any holes;IF(N_ELEMENTS(startHole) EQ 1) THEN RETURN;; Construct array of indices to blocks of good data;IF(NOT inHole) THEN startHole = [startHole, oldNT-1]nHoles = N_ELEMENTS(endHole)-1nBlocks = nHoles + 1 - inHolestartBlock=LONARR(nBlocks)endBlock = LONARR(nBlocks)FOR i=0,nBlocks-1  DO BEGIN	StartBlock[i] = endHole[i]	endBlock[i]   = startHole[i+1]-1ENDFOR;; and array of corresponding indices into the 'new' arrays;newStart = LONARR(nBlocks)newEnd   = LONARR(nBlocks)newStart[0] = 0newEnd[0] = endBlock[0] - startBlock[0]FOR i=1, nBLocks-1 DO BEGIN	newStart[i] = newEnd[i-1] + 1	newEnd[i] = newStart[i] + (endBlock[i] - startBlock[i])ENDFOR;; Construct new time series and new values array;newNT = TOTAL(endBlock) - TOTAL(startBlock) + nBlocksoldValues = *self.valuesinfo = SIZE(oldValues)newValues = MAKE_ARRAY(newNT, TYPE=TypeOF(oldValues))newTimeSeries = MAKE_ARRAY(newNT, TYPE=TypeOF(oldTimeSeries))IF(errors) THEN BEGIN	oldErrorBars = *self.ErrorBars	newErrorBars = MAKE_ARRAY(newNT, TYPE=TypeOF(oldErrorBars))ENDIFFOR i=0,nBlocks-1  DO BEGIN	newValues[newStart[i]:newEnd[i] ] = oldValues[startBlock[i]:endBlock[i] ]	newTimeSeries[ newStart[i]:newEnd[i] ] = oldTimeSeries[ startBlock[i]:endBlock[i] ]	IF(errors) THEN newErrorBars[ newStart[i]:newEnd[i] ] = oldErrorBars[startBlock[i]:endBlock[i] ]ENDFORnewValues = REFORM(newValues)newTimeSeries = REFORM(newTimeSeries);; Reset values within 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues)vMin = GKVsd_MIN(newValues, Max=vMax)self.vrange = [vmin,vmax]IF(errors) THEN BEGIN	PTR_FREE, self.ErrorBars	self.ErrorBars = PTR_NEW(newErrorBars)ENDIFPTR_Free, self.Grid1.valuesself.Grid1.values = PTR_NEW(newTimeSeries)nT = N_ELEMENTS(newTimeSeries) - 1self.Grid1.range = [newTimeSeries[0], newTimeSeries[nt]]self.Grid1.irange = [0,nT]self.Grid1.uniform = GKVsd_UniformGrid(newTimeSeries)RETURNEND ; ****** GKVs1D::Repair ****** ;PRO GKVs2D::Repair;; Purpose;;		This proceedure repairs removes 'holes';		in the time-sequence of 'self' that may;		result from bad restarts of pg3eq.;; Written by W.M. Nevins;	10/2/00;oldTimeSeries = *self.Grid2.valuesoldNT = N_ELEMENTS(oldTimeSeries)errors = PTR_VALID(self.ErrorBars);; Find 'holes' in old time series;inHole=0bstartHole = 0endHole   = 0lastT = oldTimeSeries[0]FOR i=1, oldNT-1 DO BEGIN	IF(oldTimeSeries[i] GT lastT) THEN BEGIN		IF(inHole) THEN BEGIN			IF((oldTImeSeries[i] - lastT) GT 10*dt) THEN GOTO, doneThis			endHole = [endHole, i]			inHole = 0b		ENDIF		dT = oldTimeSeries[i] - lastT		lastT = oldTimeSeries[i]	doneThis:	ENDIF ELSE BEGIN		IF( NOT inHole) THEN BEGIN			startHole = [startHole, i]			inHole = 1b		ENDIF			ENDELSEENDFOR;; Check if we found any holes;IF(N_ELEMENTS(startHole) EQ 1) THEN RETURN;; Construct array of indices to blocks of good data;IF(NOT inHole) THEN startHole = [startHole, oldNT-1]nHoles = N_ELEMENTS(endHole)-1nBlocks = nHoles + 1 - inHolestartBlock=LONARR(nBlocks)endBlock = LONARR(nBlocks)FOR i=0,nBlocks-1  DO BEGIN	StartBlock[i] = endHole[i]	endBlock[i]   = startHole[i+1]-1ENDFOR;; and array of corresponding indices into the 'new' arrays;newStart = LONARR(nBlocks)newEnd   = LONARR(nBlocks)newStart[0] = 0newEnd[0] = endBlock[0] - startBlock[0]FOR i=1, nBLocks-1 DO BEGIN	newStart[i] = newEnd[i-1] + 1	newEnd[i] = newStart[i] + (endBlock[i] - startBlock[i])ENDFOR;; Construct new time series and new values array;newNT = TOTAL(endBlock) - TOTAL(startBlock) + nBlocksoldValues = *self.valuesinfo = SIZE(oldValues)newValues = MAKE_ARRAY(info[1], newNT, TYPE=TypeOF(oldValues))newTimeSeries = MAKE_ARRAY(newNT, TYPE=TypeOF(oldTimeSeries))IF(errors) THEN BEGIN	oldErrorBars = *self.ErrorBars	newErrorBars = MAKE_ARRAY(info[1], newNT, TYPE=TypeOF(oldErrorBars))ENDIFFOR i=0,nBlocks-1  DO BEGIN	newValues[ *,newStart[i]:newEnd[i] ] = oldValues[ *,startBlock[i]:endBlock[i] ]	newTimeSeries[ newStart[i]:newEnd[i] ] = oldTimeSeries[ startBlock[i]:endBlock[i] ]	IF(errors) THEN newErrorBars[ *,newStart[i]:newEnd[i] ] = oldErrorBars[ *,startBlock[i]:endBlock[i] ]ENDFORnewValues = REFORM(newValues)newTimeSeries = REFORM(newTimeSeries);; Reset values within 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues)vMin = GKVsd_MIN(newValues, Max=vMax)self.vrange = [vmin,vmax]IF(errors) THEN BEGIN	PTR_FREE, self.ErrorBars	self.ErrorBars = PTR_NEW(newErrorBars)ENDIFPTR_Free, self.Grid2.valuesself.Grid2.values = PTR_NEW(newTimeSeries)nT = N_ELEMENTS(newTimeSeries) - 1self.Grid2.range = [newTimeSeries[0], newTimeSeries[nt]]self.Grid2.irange = [0,nT]self.Grid2.uniform = GKVsd_UniformGrid(newTimeSeries)RETURNEND ; ****** GKVs2D::Repair ****** ;PRO GKVs3D::Repair;; Purpose;;		This proceedure repairs removes 'holes';		in the time-sequence of 'self' that may;		result from bad restarts of pg3eq.;; Written by W.M. Nevins;	10/2/00;oldTimeSeries = *self.Grid3.valuesoldNT = N_ELEMENTS(oldTimeSeries)errors = PTR_VALID(self.ErrorBars);; Find 'holes' in old time series;inHole=0bstartHole = 0endHole   = 0lastT = oldTimeSeries[0]FOR i=1, oldNT-1 DO BEGIN	IF(oldTimeSeries[i] GT lastT) THEN BEGIN		IF(inHole) THEN BEGIN			IF((oldTImeSeries[i] - lastT) GT 10*dt) THEN GOTO, doneThis			endHole = [endHole, i]			inHole = 0b		ENDIF		dT = oldTimeSeries[i] - lastT		lastT = oldTimeSeries[i]	doneThis:	ENDIF ELSE BEGIN		IF( NOT inHole) THEN BEGIN			startHole = [startHole, i]			inHole = 1b		ENDIF			ENDELSEENDFOR;; Check if we found any holes;IF(N_ELEMENTS(startHole) EQ 1) THEN RETURN;; Construct array of indices to blocks of good data;IF(NOT inHole) THEN startHole = [startHole, oldNT-1]nHoles = N_ELEMENTS(endHole)-1nBlocks = nHoles + 1 - inHolestartBlock=LONARR(nBlocks)endBlock = LONARR(nBlocks)FOR i=0,nBlocks-1  DO BEGIN	StartBlock[i] = endHole[i]	endBlock[i]   = startHole[i+1]-1ENDFOR;; and array of corresponding indices into the 'new' arrays;newStart = LONARR(nBlocks)newEnd   = LONARR(nBlocks)newStart[0] = 0newEnd[0] = endBlock[0] - startBlock[0]FOR i=1, nBLocks-1 DO BEGIN	newStart[i] = newEnd[i-1] + 1	newEnd[i] = newStart[i] + (endBlock[i] - startBlock[i])ENDFOR;; Construct new time series and new values array;newNT = TOTAL(endBlock) - TOTAL(startBlock) + nBlocksoldValues = *self.valuesinfo = SIZE(oldValues)newValues = MAKE_ARRAY(info[1], info[2], newNT, TYPE=TypeOF(oldValues))newTimeSeries = MAKE_ARRAY(newNT, TYPE=TypeOF(oldTimeSeries))IF(errors) THEN BEGIN	oldErrorBars = *self.ErrorBars	newErrorBars = MAKE_ARRAY(info[1], info[2], newNT, TYPE=TypeOF(oldErrorBars))ENDIFFOR i=0,nBlocks-1  DO BEGIN	newValues[ *,*,newStart[i]:newEnd[i] ] = oldValues[ *,*,startBlock[i]:endBlock[i] ]	newTimeSeries[ newStart[i]:newEnd[i] ] = oldTimeSeries[ startBlock[i]:endBlock[i] ]	IF(errors) THEN newErrorBars[ *,*,newStart[i]:newEnd[i] ] = oldErrorBars[ *,*,startBlock[i]:endBlock[i] ]ENDFORnewValues = REFORM(newValues)newTimeSeries = REFORM(newTimeSeries);; Reset values within 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues)vMin = GKVsd_MIN(newValues, Max=vMax)self.vrange = [vmin,vmax]IF(errors) THEN BEGIN	PTR_FREE, self.ErrorBars	self.ErrorBars = PTR_NEW(newErrorBars)ENDIFPTR_Free, self.grid3.valuesself.grid3.values = PTR_NEW(newTimeSeries)nT = N_ELEMENTS(newTimeSeries) - 1self.grid3.range = [newTimeSeries[0], newTimeSeries[nt]]self.grid3.irange = [0,nT]self.grid3.uniform = GKVsd_UniformGrid(newTimeSeries)RETURNEND ; ****** GKVs3D::Repair ****** ;PRO GKVs4D::Repair;; Purpose;;		This proceedure repairs removes 'holes';		in the time-sequence of 'self' that may;		result from bad restarts of pg3eq.;; Written by W.M. Nevins;	10/2/00;oldTimeSeries = *self.grid4.valuesoldNT = N_ELEMENTS(oldTimeSeries)errors = PTR_VALID(self.ErrorBars);; Find 'holes' in old time series;inHole=0bstartHole = 0endHole   = 0lastT = oldTimeSeries[0]FOR i=1, oldNT-1 DO BEGIN	IF(oldTimeSeries[i] GT lastT) THEN BEGIN		IF(inHole) THEN BEGIN			IF((oldTImeSeries[i] - lastT) GT 10*dt) THEN GOTO, doneThis			endHole = [endHole, i]			inHole = 0b		ENDIF		dT = oldTimeSeries[i] - lastT		lastT = oldTimeSeries[i]	doneThis:	ENDIF ELSE BEGIN		IF( NOT inHole) THEN BEGIN			startHole = [startHole, i]			inHole = 1b		ENDIF			ENDELSEENDFOR;; Check if we found any holes;IF(N_ELEMENTS(startHole) EQ 1) THEN RETURN;; Construct array of indices to blocks of good data;IF(NOT inHole) THEN startHole = [startHole, oldNT-1]nHoles = N_ELEMENTS(endHole)-1nBlocks = nHoles + 1 - inHolestartBlock=LONARR(nBlocks)endBlock = LONARR(nBlocks)FOR i=0,nBlocks-1  DO BEGIN	StartBlock[i] = endHole[i]	endBlock[i]   = startHole[i+1]-1ENDFOR;; and array of corresponding indices into the 'new' arrays;newStart = LONARR(nBlocks)newEnd   = LONARR(nBlocks)newStart[0] = 0newEnd[0] = endBlock[0] - startBlock[0]FOR i=1, nBLocks-1 DO BEGIN	newStart[i] = newEnd[i-1] + 1	newEnd[i] = newStart[i] + (endBlock[i] - startBlock[i])ENDFOR;; Construct new time series and new values array;newNT = TOTAL(endBlock) - TOTAL(startBlock) + nBlocksoldValues = *self.valuesinfo = SIZE(oldValues)newValues = MAKE_ARRAY(info[1],info[2], info[3], newNT, TYPE=TypeOF(oldValues))newTimeSeries = MAKE_ARRAY(newNT, TYPE=TypeOF(oldTimeSeries))IF(errors) THEN BEGIN	oldErrorBars = *self.ErrorBars	newErrorBars = MAKE_ARRAY(info[1], info[2], info[3], newNT, TYPE=TypeOF(oldErrorBars))ENDIFFOR i=0,nBlocks-1  DO BEGIN	newValues[ *,*,*,newStart[i]:newEnd[i] ] = oldValues[ *,*,*,startBlock[i]:endBlock[i] ]	newTimeSeries[ newStart[i]:newEnd[i] ] = oldTimeSeries[ startBlock[i]:endBlock[i] ]	IF(errors) THEN newErrorBars[ *,*,*,newStart[i]:newEnd[i] ] = oldErrorBars[ *,*,*,startBlock[i]:endBlock[i] ]ENDFORnewValues = REFORM(newValues)newTimeSeries = REFORM(newTimeSeries);; Reset values within 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues)vMin = GKVsd_MIN(newValues, Max=vMax)self.vrange = [vmin,vmax]IF(errors) THEN BEGIN	PTR_FREE, self.ErrorBars	self.ErrorBars = PTR_NEW(newErrorBars)ENDIFPTR_Free, self.grid4.valuesself.grid4.values = PTR_NEW(newTimeSeries)nT = N_ELEMENTS(newTimeSeries) - 1self.grid4.range = [newTimeSeries[0], newTimeSeries[nt]]self.grid4.irange = [0,nT]self.grid4.uniform = GKVsd_UniformGrid(newTimeSeries)RETURNEND ; ****** GKVs4D::Repair ****** ;