PRO GKVs2D::EddyBasis, vPrime=vp, t=tt, forward=fwd, force=force;; Purpose:;;		This proceedure transforms 2-D spatial (x,y) data from pg3eq;		out of (or into) the shifted eddy basis used in pg3eq to impose;		global ExB shear.;;		pg3eq saves data as a function of (x, ybar), where the shifted;		coordinate, ybar, is related to the normal 'toroidal' coordinate;		y via;;			ybar = y + vPrime*t*x;;		The object being acted on, 'self', is returned with the 'toroidal';		coordinate appropriately shifted.;; Keywords:;;		vPrime	The radial derivative of the imposed velocity shear in pg3eq units.;				Defaults to 0. (optional... but then this proceedure will have no effect).;;		t		The 'time' (in pg3eq units) associate with this time-slice of the pg3eq data.;				Note that the proper coordinate transformation will be performed when ever ;				vPrime and t are in the SAME units (even in not usual pg3eq units).;				Defaults to 0. (optional... but then this proceedure will have no effect).;;		foward	Set this keyword (i.e., put "/forward" on the command line) to perform the;				transform from lab frame into the shifted eddy basis.  Default is to peform;				the transformation from the shifted eddy basis (usual form of pg3eq data as ;				imported) into the lab basis.;;		force		Set this keyword (i.e., put "/force" on the command line) to overide check for;				uniform grids, etc.;; Written by W.M. Nevins;	9/20/00;; Get inputs from command line;vPrime=0.IF KEYWORD_SET(vp)  THEN vPrime = vpIF KEYWORD_SET(fwd) THEN vPrime =-vPrimet=0IF KEYWORD_SET(tt)  THEN t = tt;; Check for uniform grid and get grid spacing;IF (KEYWORD_SET(force) or self.Grid2.uniform) THEN BEGIN	xValues = *self.Grid2.values	dx = xValues[1] - xValues[0]	nx = N_ELEMENTS(xValues)ENDIF ELSE BEGIN	MESSAGE, "radial grid is not uniform", /INFORMATIONAL	RETURNENDELSEIF (KEYWORD_SET(force) or self.Grid1.uniform) THEN BEGIN	yValues = *self.Grid1.values	dy = yValues[1] - yValues[0]	ny = N_ELEMENTS(yValues)ENDIF ELSE BEGIN	MESSAGE, "toroidal grid is not uniform", /INFORMATIONAL	RETURNENDELSE;; Get values;values = *self.values;; Begin loop over radial coordinate, performing appropriate shift ; in toroidal coordinate with linear interpolation.;const = vPrime*t*(dx/dy)newValues = FLTARR(ny, nx)FOR i = 0, nx-1 DO BEGIN	shft = i*const	iShift = FIX(shft)	dShift = shft - iShift	ySlice = values[*,i]	newValues[*,i] = (1.0-dShift)*SHIFT(ySlice, iShift) + dShift*SHIFT(ySlice, ishift+1)ENDFOR;; Now load new values into 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues);; and we're done;RETURNEND ; ****** GKVs2D::EddyBasis ****** ;PRO GKVs3D::EddyBasis, vPrime=vp, t0=tt, forward=fwd, force=force;; Purpose:;;		This proceedure transforms 2-D spatial (x,y) data from pg3eq;		out of (or into) the shifted eddy basis used in pg3eq to impose;		global ExB shear.;;		pg3eq saves data as a function of (x, ybar), where the shifted;		coordinate, ybar, is related to the normal (lab) 'toroidal' ;		coordinate y via;;			ybar = y + vPrime*t*x;;		The object being acted on, 'self', is returned with the 'toroidal';		coordinate appropriately shifted.;; Keywords:;;		vPrime	The radial derivative of the imposed velocity shear in pg3eq units.;				Defaults to 0. (optional... but then this proceedure will have no effect).;;		t0		Overall shift to be applied to the pg3eq time coordinate.;				Defaults to 0 (optional).;;		foward		Set this keyword (i.e., put "/forward" on the command line) to perform the;				transform from lab frame into the shifted eddy basis.  Default is to peforom;				the transformation from the shifted eddy basis (usual form of pg3eq data as ;				imported) into the lab basis.;;		force		Set this keyword (i.e., put "/force" on the command line) to overide check for;				uniform grids, etc.;; Written by W.M. Nevins;	9/20/00;; Get inputs from command line;vPrime=0.IF KEYWORD_SET(vp)  THEN vPrime = vpIF KEYWORD_SET(fwd) THEN vPrime =-vPrimet0=0IF KEYWORD_SET(tt)  THEN t0 = tt;; Check for uniform grid and get grid spacing;IF (KEYWORD_SET(force) or self.Grid2.uniform) THEN BEGIN	xValues = *self.Grid2.values	dx = xValues[1] - xValues[0]	nx = N_ELEMENTS(xValues)ENDIF ELSE BEGIN	MESSAGE, "radial grid is not uniform", /INFORMATIONAL	RETURNENDELSEIF (KEYWORD_SET(force) or self.Grid1.uniform) THEN BEGIN	yValues = *self.Grid1.values	dy = yValues[1] - yValues[0]	ny = N_ELEMENTS(yValues)ENDIF ELSE BEGIN	MESSAGE, "toroidal grid is not uniform", /INFORMATIONAL	RETURNENDELSEtValues = *self.Grid3.valuesnt = N_ELEMENTS(tValues);; Begin loop over radial coordinate, performing appropriate shift ; in toroidal coordinate with linear interpolation.;newValues = FLTARR(ny, nx, nt)FOR k = 0, nt-1 DO BEGIN	t = t0 + tvalues[k]	const = vPrime*t*(dx/dy)	;	; Get values	;	values = REFORM((*self.values)[*,*,k])	FOR i = 0, nx-1 DO BEGIN		shft = i*const		iShift = FIX(shft)		dShift = shft - iShift		ySlice = values[*,i]		newValues[*,i,k] = (1.0-dShift)*SHIFT(ySlice, iShift) + dShift*SHIFT(ySlice, ishift+1)	ENDFORENDFOR;; Now load new values into 'self';PTR_FREE, self.valuesself.values = PTR_NEW(newValues);; and we're done;RETURNEND ; ****** GKVs3D::EddyBasis ****** ;