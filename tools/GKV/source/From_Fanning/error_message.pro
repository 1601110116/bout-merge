;+; NAME:;    ERROR_MESSAGE;; PURPOSE:;    The purpose of this function  is to have a device-independent;    error messaging function. The error message is reported;    to the user by using DIALOG_MESSAGE if widgets are;    supported and MESSAGE otherwise.;; CATEGORY:;    Utility.;; CALLING SEQUENCE:;    ok = Error_Message(the_Error_Message);; INPUTS:;    the_Error_Message: This is a string argument containing the error;       message you want reported. If undefined, this variable is set;       to the string in the !Error_State.Msg system variable.;; KEYWORDS:;    TRACEBACK: Setting this keyword results in an error traceback;       being printed to standard output with the PRINT command.; OUTPUTS:;    Currently the only output from the function is the string "OK".;; RESTRICTIONS:;    The "Warning" Dialog_Message dialog is used.;; EXAMPLE:;    To handle an undefined variable error:;;    IF N_Elements(variable) EQ 0 THEN $;       ok = Error_Message('Variable is undefined', /Traceback);; MODIFICATION HISTORY:;    Written by: David Fanning, 27 April 1999.;-FUNCTION ERROR_MESSAGE, theMessage, Traceback=tracebackOn_Error, 2   ; Check for presence and type of message.IF N_Elements(theMessage) EQ 0 THEN theMessage = !Error_State.Msgs = Size(theMessage)messageType = s[s[0]+1]IF messageType NE 7 THEN BEGIN   Message, "The message parameter must be a string."ENDIF   ; Are widgets supported?widgetsSupported = ((!D.Flags AND 65536L) NE 0)IF widgetsSupported THEN answer = Dialog_Message(theMessage) ELSE BEGIN      Message, theMessage, /Continue, /NoPrint, /NoName, /NoPrefix      Help, Calls=callStack         ; Find the calling routine's name.      callingRoutine = (Str_Sep(StrCompress(callStack[1])," "))[0]      Print, '%' + callingRoutine + ': ' + theMessage      answer = 'OK'ENDELSE   ; Provide traceback information if requested.IF Keyword_Set(traceback) THEN BEGIN   Help, /Last_Message, Output=traceback   FOR j=0,N_Elements(traceback)-1 DO Print, traceback[j]ENDIFRETURN, answerEND