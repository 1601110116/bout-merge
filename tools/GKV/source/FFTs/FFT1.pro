FUNCTION GKVs1D::FFT1, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in first independent variable to fourier space representation; in first independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by W.M. Nevins;  11/24/01;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid1.uniformIF(NOT uniform) THEN self -> ScaleAxis, 1, /Uniformboundary=self.grid1.boundaryirangeIn = self.grid1.irangenxIn = N_ELEMENTS(*self.grid1.values)nxInEven = 2*(nxIn/2)-nxIn+1	; will be =1 if nxIn is even, =0 if nxIn is oddCASE boundary OF	'periodic (open)'	:	irange=[0,nxIn-1]	'periodic (closed)'	:	irange=[0,nxIn-2]	'periodic'		:	irange=[0,nxIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=1, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=1, irange=irangeIninfo=SIZE(values)nx  = info[1]nxEven = 2*(nx/2)-nx+1	; will be =1 if nx is even, =0 if nx is oddnxOdd = 1 - nxEvenikx = nx;; Shift k-values if this is an inverse transform;kxShift = (ikx-1)/2 + 1IF inverse THEN values = SHIFT(values, kxShift)kSpaceValues = FFT(values, direction);; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx; if this is a foward transform;IF( NOT INVERSE) THEN kSpaceValues = SHIFT(kSpaceValues,  -kxShift);; Add boundary layer to 'close' transform data; if even number of data points;IF(nxEven) THEN BEGIN	temp = COMPLEXARR(ikx+nxEven)	temp[0:(nx-1)] = kSpaceValues	temp[nx] = temp[0]	ikx=ikx+nxEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/ikx;	1	:	kSpaceValues = kSpaceValues*ikx;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0]CASE boundary OF	'periodic (open)'	:	lx=lx + dx	'periodic (closed)'	:	lx=lx + dx	'periodic'		:	lx=lx + dxELSE:	lx=lxENDCASEdkx = 2.*!PI/lxxMnemonic = STRTRIM(self.Grid1.mnemonic, 2)xTitle=self.grid1.titlexUnits=self.grid1.unitsIF(STRMATCH(xUnits, 'dimensionless')) THEN xUnits=''new_xUnits = GKV_InvertString(xUnits)result.Grid1.units = new_xUnitsIF inverse THEN BEGIN	kxGrid = dkx*FINDGEN(ikx) ;*(FLOAT(ikx-1)/FLOAT(ikx))	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; 	CASE STRLOWCASE(xMnemonic) OF		'omega':	BEGIN			result.grid1.mnemonic = 't'			result.grid1.title = 't'				END		'n'	:	BEGIN			result.grid1.mnemonic = 'zeta'			result.grid1.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(xMnemonic, 'k_', /EXTRACT)			result.Grid1.mnemonic = STRJOIN(mnemonicSubStrings, 'k_')			titleChars = STRLEN(xTitle)			newLength = titleChars - 5			result.Grid1.title = STRMID(xTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kxGrid = dkx*(FINDGEN(ikx) - (ikx-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(xMnemonic EQ 't') THEN BEGIN		result.grid1.mnemonic = 'omega'		result.grid1.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid1.mnemonic = 'k_' + xMnemonic		xtitle=self.grid1.title		result.Grid1.title = 'k!D' + xTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.irange = [0,ikx-1]result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]CASE nxEven OF	0	:	result.grid1.boundary = 'periodic (open)'	1	:	result.grid1.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 1, const=1., offset=offsetRETURN, resultEND ; ****** GKVs1D::FFT1 ****** ;FUNCTION GKVs2D::FFT1, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in first independent variable to fourier space representation; in first independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by W.M. Nevins;  11/24/01;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid1.uniformIF(NOT uniform) THEN self -> ScaleAxis, 1, /Uniformboundary=self.grid1.boundaryirangeIn = self.grid1.irangenxIn = N_ELEMENTS(*self.grid1.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nxIn-1]	'periodic (closed)'	:	irange=[0,nxIn-2]	'periodic'		:	irange=[0,nxIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=1, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=1, irange=irangeIninfo=SIZE(values)nx  = info[1]nt = info[2]nxEven = 2*(nx/2)-nx+1	; will be =1 if nx is even, =0 if nx is oddnxOdd = 1 - nxEvenikx = nx;; Shift k-values if this is an inverse transform;kxShift = (ikx-1)/2 + 1IF inverse THEN values = SHIFT(values, kxShift, 0);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(ikx, nt);; Begin loop over time-slices;FOR it = 0, nt-1 DO BEGIN	; Fourier transform	kSpaceValues[*,it] = FFT(values[*,it], direction)ENDFOR;; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx; if this is a foward transform.;IF(NOT inverse) THEN kSpaceValues = SHIFT(kSpaceValues,  -kxShift, 0);; Add boundary layer to 'close' transform data; if even number of data points;IF(nxEven) THEN BEGIN	temp = COMPLEXARR(ikx+nxEven, nt)	temp[0:(nx-1),*] = kSpaceValues	temp[nx,*] = temp[0,*]	ikx=ikx+nxEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/ikx;	1	:	kSpaceValues = kSpaceValues*ikx;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0]CASE boundary OF	'periodic (open)'	:	lx=lx + dx	'periodic (closed)'	:	lx=lx + dx	'periodic'		:	lx=lx + dxELSE:	lx=lxENDCASEdkx = 2.*!PI/lxxMnemonic = STRTRIM(self.Grid1.mnemonic, 2)xTitle=self.grid1.titlexUnits=self.grid1.unitsIF(STRMATCH(xUnits, 'dimensionless')) THEN xUnits=''new_xUnits = GKV_InvertString(xUnits)result.Grid1.units = new_xUnitsIF inverse THEN BEGIN	kxGrid = dkx*FINDGEN(ikx)	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; CASE STRLOWCASE(xMnemonic) OF		'omega':	BEGIN			result.grid1.mnemonic = 't'			result.grid1.title = 't'				END		'n'	:	BEGIN			result.grid1.mnemonic = 'zeta'			result.grid1.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(xMnemonic, 'k_', /EXTRACT)			result.Grid1.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(xTitle)			newLength = titleChars - 5			result.Grid1.title = STRMID(xTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kxGrid = dkx*(FINDGEN(ikx) - (ikx-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(xMnemonic EQ 't') THEN BEGIN		result.grid1.mnemonic = 'omega'		result.grid1.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid1.mnemonic = 'k_' + xMnemonic		xtitle=self.grid1.title		result.Grid1.title = 'k!D' + xTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.irange = [0,ikx-1]result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]CASE nxEven OF	0	:	result.grid1.boundary = 'periodic (open)'	1	:	result.grid1.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 1, const=1., offset=offsetRETURN, resultEND ; ****** GKVs2D::FFT1 ****** ;FUNCTION GKVs3D::FFT1, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in first independent variable to fourier space representation; in first independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by W.M. Nevins;  11/24/01;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid1.uniformIF(NOT uniform) THEN self -> ScaleAxis, 1, /Uniformboundary=self.grid1.boundaryirangeIn = self.grid1.irangenxIn = N_ELEMENTS(*self.grid1.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nxIn-1]	'periodic (closed)'	:	irange=[0,nxIn-2]	'periodic'		:	irange=[0,nxIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=1, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=1, irange=irangeIninfo=SIZE(values)nx = info[1]ny = info[2]nt = info[3]nxEven = 2*(nx/2)-nx+1	; will be =1 if nx is even, =0 if nx is oddnxOdd = 1 - nxEvenikx = nx;; Shift k-values if this is an inverse transform;kxShift = (ikx-1)/2 + 1IF inverse THEN values = SHIFT(values, kxShift, 0, 0);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(ikx, ny, nt);; Begin loop over y-slices and time-slices;FOR iy = 0, ny-1 DO BEGIN	FOR it = 0, nt-1 DO BEGIN	; Fourier transform		kSpaceValues[*,iy,it] = FFT(values[*,iy,it], direction)	ENDFORENDFOR;; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx; if this is a foward transform.;IF( NOT INVERSE) THEN kSpaceValues = SHIFT(kSpaceValues,  -kxShift, 0, 0);; Add boundary layer to 'close' transform data; if even number of data points;IF(nxEven) THEN BEGIN	temp = COMPLEXARR(ikx+nxEven, ny, nt)	temp[0:(nx-1),*,*] = kSpaceValues	temp[nx,*,*] = temp[0,*,*]	ikx=ikx+nxEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/ikx;	1	:	kSpaceValues = kSpaceValues*ikx;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0]CASE boundary OF	'periodic (open)'	:	lx=lx + dx	'periodic (closed)'	:	lx=lx + dx	'periodic'		:	lx=lx + dxELSE:	lx=lxENDCASEdkx = 2.*!PI/lxxMnemonic = STRTRIM(self.Grid1.mnemonic, 2)xTitle=self.grid1.titlexUnits=self.grid1.unitsIF(STRMATCH(xUnits, 'dimensionless')) THEN xUnits=''new_xUnits = GKV_InvertString(xUnits)result.Grid1.units = new_xUnitsIF inverse THEN BEGIN	kxGrid = dkx*FINDGEN(ikx) ;*(FLOAT(ikx-1)/FLOAT(ikx))	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; CASE STRLOWCASE(xMnemonic) OF		'omega':	BEGIN			result.grid1.mnemonic = 't'			result.grid1.title = 't'				END		'n'	:	BEGIN			result.grid1.mnemonic = 'zeta'			result.grid1.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(xMnemonic, 'k_', /EXTRACT)			result.Grid1.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(xTitle)			newLength = titleChars - 5			result.Grid1.title = STRMID(xTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kxGrid = dkx*(FINDGEN(ikx) - (ikx-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(xMnemonic EQ 't') THEN BEGIN		result.grid1.mnemonic = 'omega'		result.grid1.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid1.mnemonic = 'k_' + xMnemonic		xtitle=self.grid1.title		result.Grid1.title = 'k!D' + xTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.irange = [0,ikx-1]result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]CASE nxEven OF	0	:	result.grid1.boundary = 'periodic (open)'	1	:	result.grid1.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 1, const=1., offset=offsetRETURN, resultEND ; ****** GKVs3D::FFT1 ****** ;FUNCTION GKVs4D::FFT1, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in first independent variable to fourier space representation; in first independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by E. Wang;  5-7-09;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid1.uniformIF(NOT uniform) THEN self -> ScaleAxis, 1, /Uniformboundary=self.grid1.boundaryirangeIn = self.grid1.irangenxIn = N_ELEMENTS(*self.grid1.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nxIn-1]	'periodic (closed)'	:	irange=[0,nxIn-2]	'periodic'		:	irange=[0,nxIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=1, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=1, irange=irangeIninfo=SIZE(values)nx = info[1]ny = info[2]nz = info[3]nt = info[4]nxEven = 2*(nx/2)-nx+1	; will be =1 if nx is even, =0 if nx is oddnxOdd = 1 - nxEvenikx = nx;; Shift k-values if this is an inverse transform;kxShift = (ikx-1)/2 + 1IF inverse THEN values = SHIFT(values, kxShift, 0, 0, 0);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(ikx, ny, nz, nt);; Begin loop over y-slices and time-slices;FOR iy = 0, ny-1 DO BEGIN    FOR iz = 0, nz-1 DO BEGIN        FOR it = 0, nt-1 DO BEGIN ; Fourier transform            kSpaceValues[*,iy,iz,it] = FFT(values[*,iy,iz,it], direction)        ENDFOR    ENDFORENDFOR;; Shift 'kSpaceValues' such that negative; values of kx preceed positive values of kx; if this is a foward transform.;IF( NOT INVERSE) THEN kSpaceValues = SHIFT(kSpaceValues,  -kxShift, 0, 0, 0);; Add boundary layer to 'close' transform data; if even number of data points;IF(nxEven) THEN BEGIN	temp = COMPLEXARR(ikx+nxEven, ny, nz, nt)	temp[0:(nx-1),*, *,*] = kSpaceValues	temp[nx,*,*,*] = temp[0,*,*,*]	ikx=ikx+nxEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/ikx;	1	:	kSpaceValues = kSpaceValues*ikx;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];xGrid = *self.Grid1.Valueslx = xGrid[nx-1] - xGrid[0]dx = xGrid[1] - xgrid[0]CASE boundary OF	'periodic (open)'	:	lx=lx + dx	'periodic (closed)'	:	lx=lx + dx	'periodic'		:	lx=lx + dxELSE:	lx=lxENDCASEdkx = 2.*!PI/lxxMnemonic = STRTRIM(self.Grid1.mnemonic, 2)xTitle=self.grid1.titlexUnits=self.grid1.unitsIF(STRMATCH(xUnits, 'dimensionless')) THEN xUnits=''new_xUnits = GKV_InvertString(xUnits)result.Grid1.units = new_xUnitsIF inverse THEN BEGIN	kxGrid = dkx*FINDGEN(ikx) ;*(FLOAT(ikx-1)/FLOAT(ikx))	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; CASE STRLOWCASE(xMnemonic) OF		'omega':	BEGIN			result.grid1.mnemonic = 't'			result.grid1.title = 't'				END		'n'	:	BEGIN			result.grid1.mnemonic = 'zeta'			result.grid1.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(xMnemonic, 'k_', /EXTRACT)			result.Grid1.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(xTitle)			newLength = titleChars - 5			result.Grid1.title = STRMID(xTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kxGrid = dkx*(FINDGEN(ikx) - (ikx-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(xMnemonic EQ 't') THEN BEGIN		result.grid1.mnemonic = 'omega'		result.grid1.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid1.mnemonic = 'k_' + xMnemonic		xtitle=self.grid1.title		result.Grid1.title = 'k!D' + xTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid1.valuesresult.Grid1.values = PTR_NEW(kxGrid)result.Grid1.irange = [0,ikx-1]result.Grid1.range = [kxGrid[0], kxGrid[ikx-1]]CASE nxEven OF	0	:	result.grid1.boundary = 'periodic (open)'	1	:	result.grid1.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 1, const=1., offset=offsetRETURN, resultEND ; ****** GKVs4D::FFT1 ****** ;