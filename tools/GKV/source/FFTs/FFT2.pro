FUNCTION GKVs2D::FFT2, Inverse=inverse, offset=offset;; Purpose:;; 	This function-method Transforms object from configuration ; 	space representation in second independent variable to ; 	fourier space representation in second independent variable.   ;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by W.M. Nevins;  11/24/01;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid2.uniformIF(NOT uniform) THEN self -> ScaleAxis, 2, /Uniformboundary=self.grid2.boundaryirangeIn = self.grid2.irangenyIn = N_ELEMENTS(*self.grid2.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nyIn-1]	'periodic (closed)'	:	irange=[0,nyIn-2]	'periodic'		:	irange=[0,nyIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=2, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=2, irange=irangeIninfo=SIZE(values)nx  = info[1]ny = info[2]nyEven = 2*(ny/2)-ny+1	; will be =1 if ny is even, =0 if ny is oddnyOdd = 1 - nyEveniky = ny;; Shift k-values if this is an inverse transform;kyShift = (iky-1)/2 + 1IF inverse THEN values = SHIFT(values, 0, kyShift);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(nx, iky);; Begin loop over time-slices;FOR ix = 0, nx-1 DO BEGIN	; Fourier transform	kSpaceValues[ix,*] = FFT(values[ix,*], direction)ENDFOR;; Shift 'kSpaceValues' such that negative; values of ky preceed positive values of ky; if this is a foward transform.;IF(NOT inverse) THEN kSpaceValues = SHIFT(kSpaceValues,  0, -kyShift);; Add boundary layer to 'close' transform data; if even number of data points;IF(nyEven) THEN BEGIN	temp = COMPLEXARR(nx, iky+nyEven)	temp[*,0:(ny-1)] = kSpaceValues	temp[*,ny] = temp[*,0]	iky=iky+nyEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/iky;	1	:	kSpaceValues = kSpaceValues*iky;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];yGrid = *self.Grid2.Valuesly = yGrid[ny-1] - yGrid[0]dy = yGrid[1] - yGrid[0]CASE boundary OF	'periodic (open)'	:	ly=ly + dy	'periodic (closed)'	:	ly=ly + dy	'periodic'		:	ly=ly + dyELSE:	ly=lyENDCASEdky = 2.*!PI/lyyMnemonic = STRTRIM(self.Grid2.mnemonic, 2)yTitle=self.grid2.titleyUnits=self.grid2.unitsIF(STRMATCH(yUnits, 'dimensionless')) THEN yUnits=''new_yUnits = GKV_InvertString(yUnits)result.Grid2.units = new_yUnitsIF inverse THEN BEGIN	kyGrid = dky*FINDGEN(iky)	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; CASE STRLOWCASE(yMnemonic) OF		'omega':	BEGIN			result.grid2.mnemonic = 't'			result.grid2.title = 't'				END		'n'	:	BEGIN			result.grid2.mnemonic = 'zeta'			result.grid2.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(yMnemonic, 'k_', /EXTRACT)			result.Grid2.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(yTitle)			newLength = titleChars - 5			result.Grid2.title = STRMID(yTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kyGrid = dky*(FINDGEN(iky) - (iky-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(yMnemonic EQ 't') THEN BEGIN		result.grid2.mnemonic = 'omega'		result.grid2.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid2.mnemonic = 'k_' + yMnemonic		ytitle=self.grid2.title		result.Grid2.title = 'k!D' + yTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid2.valuesresult.Grid2.values = PTR_NEW(kyGrid)result.Grid2.irange = [0,iky-1]result.Grid2.range = [kyGrid[0], kyGrid[iky-1]]CASE nyEven OF	0	:	result.grid2.boundary = 'periodic (open)'	1	:	result.grid2.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 2, const=1., offset=offsetRETURN, resultEND ; ****** GKVs2D::FFT2 ****** ;FUNCTION GKVs3D::FFT2, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in second independent variable to fourier space representation; in second independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by W.M. Nevins;  11/24/01;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid2.uniformIF(NOT uniform) THEN self -> ScaleAxis, 2, /Uniformboundary=self.Grid2.boundaryirangeIn = self.Grid2.irangenyIn = N_ELEMENTS(*self.Grid2.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nyIn-1]	'periodic (closed)'	:	irange=[0,nyIn-2]	'periodic'		:	irange=[0,nyIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=2, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=2, irange=irangeIninfo=SIZE(values)nx = info[1]ny = info[2]nt = info[3]nyEven = 2*(ny/2)-ny+1	; will be =1 if ny is even, =0 if ny is oddnyOdd = 1 - nyEveniky = ny;; Shift k-values if this is an inverse transform;kyShift = (iky-1)/2 + 1IF inverse THEN values = SHIFT(values, 0, kyShift, 0);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(nx, iky, nt);; Begin loop over y-slices and time-slices;FOR ix = 0, nx-1 DO BEGIN	; Fourier transform	FOR it = 0, nt-1 DO BEGIN		kSpaceValues[ix,*,it] = FFT(values[ix,*,it], direction)	ENDFORENDFOR;; Shift 'kSpaceValues' such that negative; values of ky preceed positive values of ky; if this is a foward transform.;IF( NOT INVERSE) THEN kSpaceValues = SHIFT(kSpaceValues, 0,-kyShift, 0);; Add boundary layer to 'close' transform data; if even number of data points;IF(nyEven) THEN BEGIN	temp = COMPLEXARR(nx, iky+nyEven, nt)	temp[*,0:(ny-1),*] = kSpaceValues	temp[*,ny,*] = temp[*,0,*]	iky=iky+nyEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/iky;	1	:	kSpaceValues = kSpaceValues*iky;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];yGrid = *self.Grid2.Valuesly = yGrid[ny-1] - yGrid[0]dy = yGrid[1] - yGrid[0]CASE boundary OF	'periodic (open)'	:	ly=ly + dy	'periodic (closed)'	:	ly=ly + dy	'periodic'		:	ly=ly + dyELSE:	ly=lyENDCASEdky = 2.*!PI/lyyMnemonic = STRTRIM(self.Grid2.mnemonic, 2)yTitle=self.grid2.titleyUnits=self.grid2.unitsIF(STRMATCH(yUnits, 'dimensionless')) THEN yUnits=''new_yUnits = GKV_InvertString(yUnits)result.Grid2.units = new_yUnitsIF inverse THEN BEGIN	kyGrid = dky*FINDGEN(iky)	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; 	CASE STRLOWCASE(yMnemonic) OF		'omega':	BEGIN			result.grid2.mnemonic = 't'			result.grid2.title = 't'				END		'n'	:	BEGIN			result.grid2.mnemonic = 'zeta'			result.grid2.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(yMnemonic, 'k_', /EXTRACT)			result.Grid2.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(yTitle)			newLength = titleChars - 5			result.Grid2.title = STRMID(yTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kyGrid = dky*(FINDGEN(iky) - (iky-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(yMnemonic EQ 't') THEN BEGIN		result.grid2.mnemonic = 'omega'		result.grid2.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid2.mnemonic = 'k_' + yMnemonic		result.Grid2.title = 'k!D' + yTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid2.valuesresult.Grid2.values = PTR_NEW(kyGrid)result.Grid2.irange = [0,iky-1]result.Grid2.range = [kyGrid[0], kyGrid[iky-1]]CASE nyEven OF	0	:	result.grid2.boundary = 'periodic (open)'	1	:	result.grid2.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 2, const=1., offset=offsetRETURN, resultEND ; ****** GKVs3D::FFT2 ****** ;FUNCTION GKVs4D::FFT2, Inverse=inverse, offset=offset;; Transforms object from configuration space representation; in second independent variable to fourier space representation; in second independent variable.;; Keywords:;;	inverse		Set this keyword (i.e., put "/Inverse" on command line);			to perform inverse transform. (Optional);;	offset		Set equal to desired minimum value of dependent;			variable on inverse transform.  Defaults to ;			zero (optional).;; Written by E. Wang;  5-7-09;direction=-1inverse = KEYWORD_SET(inverse)IF inverse THEN direction=1uniform = self.Grid2.uniformIF(NOT uniform) THEN self -> ScaleAxis, 2, /Uniformboundary=self.Grid2.boundaryirangeIn = self.Grid2.irangenyIn = N_ELEMENTS(*self.Grid2.values)CASE boundary OF	'periodic (open)'	:	irange=[0,nyIn-1]	'periodic (closed)'	:	irange=[0,nyIn-2]	'periodic'		:	irange=[0,nyIn-2]ELSE:	irange=irangeInENDCASEself -> Set, axis=2, irange=irange;values=*(self -> GetValues())valueptr = self -> getvalues()values = *valueptrPTR_FREE, valueptrself -> Set, axis=2, irange=irangeIninfo=SIZE(values)nx = info[1]ny = info[2]nz = info[3]nt = info[4]nyEven = 2*(ny/2)-ny+1	; will be =1 if ny is even, =0 if ny is oddnyOdd = 1 - nyEveniky = ny;; Shift k-values if this is an inverse transform;kyShift = (iky-1)/2 + 1IF inverse THEN values = SHIFT(values, 0, kyShift, 0, 0);; Make array to hold k-space representation of data;kSpaceValues = COMPLEXARR(nx, iky, nz, nt);; Begin loop over y-slices and time-slices;FOR ix = 0, nx-1 DO BEGIN	; Fourier transform    FOR iz = 0, nz-1 DO BEGIN        FOR it = 0, nt-1 DO BEGIN            kSpaceValues[ix,*,iz,it] = FFT(values[ix,*,iz,it], direction)        ENDFOR    ENDFORENDFOR;; Shift 'kSpaceValues' such that negative; values of ky preceed positive values of ky; if this is a foward transform.;IF( NOT INVERSE) THEN kSpaceValues = SHIFT(kSpaceValues, 0,-kyShift, 0, 0);; Add boundary layer to 'close' transform data; if even number of data points;IF(nyEven) THEN BEGIN	temp = COMPLEXARR(nx, iky+nyEven, nz, nt)	temp[*,0:(ny-1),*,*] = kSpaceValues	temp[*,ny,*,*] = temp[*,0,*,*]	iky=iky+nyEven	kSpaceValues = tempENDIF;; Correct normalization;;CASE inverse OF;	0	:	kSpaceValues = kSpaceValues/iky;	1	:	kSpaceValues = kSpaceValues*iky;ENDCASE;; Make copy of 'self' to store results in;Result = self -> MakeCopy(/NoValues, /NoErrorBars)result.values = PTR_NEW(kSpaceValues)vmin = GKVsd_MIN(kSpaceValues, MAX=vmax)result.vrange = [vmin,vmax];yGrid = *self.Grid2.Valuesly = yGrid[ny-1] - yGrid[0]dy = yGrid[1] - yGrid[0]CASE boundary OF	'periodic (open)'	:	ly=ly + dy	'periodic (closed)'	:	ly=ly + dy	'periodic'		:	ly=ly + dyELSE:	ly=lyENDCASEdky = 2.*!PI/lyyMnemonic = STRTRIM(self.Grid2.mnemonic, 2)yTitle=self.grid2.titleyUnits=self.grid2.unitsIF(STRMATCH(yUnits, 'dimensionless')) THEN yUnits=''new_yUnits = GKV_InvertString(yUnits)result.Grid2.units = new_yUnitsIF inverse THEN BEGIN	kyGrid = dky*FINDGEN(iky)	;	; Create x-space mnemonic by deleting the	; 'k_' which should preface the configuration-space 	; mnemonic (and remove any embedded blanks).	; 	CASE STRLOWCASE(yMnemonic) OF		'omega':	BEGIN			result.grid2.mnemonic = 't'			result.grid2.title = 't'				END		'n'	:	BEGIN			result.grid2.mnemonic = 'zeta'			result.grid2.title = '!4f!X'				END		ELSE	: 	BEGIN			mnemonicSubStrings = STRSPLIT(yMnemonic, 'k_', /EXTRACT)			result.Grid2.mnemonic = STRJOIN(mnemonicSubStrings, '_')			titleChars = STRLEN(yTitle)			newLength = titleChars - 5			result.Grid2.title = STRMID(yTitle, 3, newLength)		END	ENDCASE	ENDIF ELSE BEGIN	kyGrid = dky*(FINDGEN(iky) - (iky-1)/2)	;	; Create k-space mnemonic by prefacing the	; configuration-space mnemonic with  a 'k_'	; after removing any embedded blanks.	; 	IF(yMnemonic EQ 't') THEN BEGIN		result.grid2.mnemonic = 'omega'		result.grid2.title = '!4x!X'	ENDIF ELSE BEGIN		result.Grid2.mnemonic = 'k_' + yMnemonic		result.Grid2.title = 'k!D' + yTitle + '!N'	ENDELSEENDELSEPTR_FREE, result.Grid2.valuesresult.Grid2.values = PTR_NEW(kyGrid)result.Grid2.irange = [0,iky-1]result.Grid2.range = [kyGrid[0], kyGrid[iky-1]]CASE nyEven OF	0	:	result.grid2.boundary = 'periodic (open)'	1	:	result.grid2.boundary = 'periodic (closed)'ENDCASEIF(KEYWORD_SET(offset)) THEN result -> ScaleAxis, 2, const=1., offset=offsetRETURN, resultEND ; ****** GKVs4D::FFT2 ****** ;