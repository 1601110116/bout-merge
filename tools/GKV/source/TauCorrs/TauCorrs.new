FUNCTION GKVs3D::TauCorrs, arg, CorrFcns=CorrFcnArr, yCorrFcns=yCorrArr,  kSpects=kSpectArr, _EXTRA=extra;; Purpose:;;		This function performs a correlation analysis of 'self';		(a GKVs3D object) as a function of the specified independent;		variable (which is assumed to be  inhomogeneous). If the system ;		is homogeneous, it is ***MUCH*** more efficient to simply ;		compute the correlation function with Xcorr (with no reference ;		object).;;; Input Arguments:;;		GKVs3D::TauCorrs will accept any legal axis identifier;		(that is, an integer between 1 and 3, or a valid;		axis mnemonic) as an argument.  If no argument is ;		provided, then GKVs3D::TauCorrs will expect the axis;		corresponding to the inhomogeneous coordinate to be;		identified by keywords (see below). (Optional);;;  Input Keywords:;;	     Axis	If no argument is provided, then this keyword may be ;			used to identify the inhomogeneous coordinate. Set axis ;			equal to any legal axis identifier (see above).;			(optional);;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the selected independent ;			variable, and reset the signal window on this axis.;			This two-element array is interpreted as the desired RANGE in;			the independent variable (i.e., it is interpreted in the units;			of the corresponding independent variable), NOT the integer 'irange';			(that is, NOT as an integer index into the grid.values array).;			(optional);;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window of the selected independent variable.  The value of irange;			is interpreted as an index into the grid.values array.  'irange';			defaults to the current signal window of 'self.;			(optional);;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable.;			(optional);;	     skip	The sampling interval for the specified inhomogeneous independent;			variable.  Defaults to 1 (Optional).;;	localNorm  	Set this keyword (i.e., put '/LocalNorm' on the command line) to normalize;			the data from 'self' (but not 'self' itself, whose data remains unaltered);			such that the rms fluctuation at each value of the specified inhomogeneous;			independent variable is the same BEFORE  computing the correlation time.;			(Optional);;	    debug	Set this keyword (i.e., put '/debug' on the command line) to ;			print out intermediate information, allowing the user to keep track;			of the progress (or lack thereof...) of this function. ;			(optional);;	 fraction	Normally TauCorrs returns the fullwidth at half maximum of the correlation;			function vs. the specified axis.  If this keyword is set, RCORR will ;			instead compute the full width at 'fraction' of maximum vs. time.;			Defaults to 0.5 (Optional).;			;;; Output:  	GKVs3D::TauCorrs returns a a structure with the following tags.  ;		Additional tags can be included by setting output keywords ;		(see "Output Keywords" below).;		;	TauCorr 	A GKVs1D object containing the correlation time;			(full-width at half-maximum measured along the;			maximum of the local correlation function) vs. ;			the specified inhomogeneous independent variable.;;	vPhase		A GKVs1D object containing the phase velocity;			(slope of the maximum in the local correlation ;			function) vs. the inhomogenous independent variable. ;;	yCorr		A GKVs1D object containing the correlation length in;			the remaining independent variable (full-width at;			half maximum of the Hilbert-transform 'envelope';			of the oscillatory local correlation function evaluated;			at zero time lag) vs. the inhomogeneous variable.;			;;	kAvg		A GKVs1D object containing the power-weighted avgerage  ;			wave number in the remaining (persumably homogeneous) ;			independent variable vs. the inhomogeneous variable. ;			The error bars on kAvg represent the power-weighted;			standard deviation about this mean wave number.;;	kSpect		A GKVs1D object containing the average (over the inhomogeneous;			variable) of the local frequency-integrated spectrum vs. the ;			wave number associated with the remaining independent variable.;			If the /LocalNorm keyword is set, then this is a volume average,;			while if it is not set, then this is a power-weighted volume;			average.;;	CorrFcn		A GKVs1D object containing the (volume or power-weighted volume as;			with kSpect above) average over the inhomogeneous coordinate;			of the maximum of the local correlation function vs. the time lag.;;	yCorrFcn	A GKVs1D object containing the (volume or power-weighted volume as;			with kSpect above) average over the inhomogeneous coordinate of the;			local corrlation function vs. the remaining independent variable;			evaluated at zero time lag.;;;  Output Keywords:;;	 CorrFcns	Set this keyword (i.e., put "/CorrFcns" on the command line);			to add the tag "CorrFcnArr" to the output structure.  The;			corresponding value is  an array of GKVs1D objects ;			containing the local correlation function vs. tau for each location;			at which the correlation time is computed. (Optional);;	yCorrFcns	Set this keyword (i.e., put "/yCorrFcns" on the command line);			to add the tag "yCorrFcnArr" to the output structure.  The;			corresponding value is an array of GKVs1D objects;			containing the local correlation function vs. the homogeneous;			spatial coordinate at each radial location at which the correlation;			function in computed. (Optional);			;	  kSpects	Set this keyword (i.e., put "/kSpects" on the command line);			to add the tag "kSpectArr" to the output structure.  The;			corresponding value is an array of GKVs1D objects;			containing the local k-spectrum (integrated over frequency);			vs. the homogeneous spatial coordinate at each radial location ;			at which the correlation function in computed. (Optional);			;;;; Side Effects:;;		Resets the signal window of 'self' to specified 'range' or 'irange' if;		one is provided with any of the keywords 'mnemonic', irange, or range;	;; Written by W.M. Nevins;	9/28/00;;; Get info from command line:;; First find identifier for axis corresponding to ; the inhomogeneous independent variable;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	ELSE	:	BEGIN				MESSAGE, 'RCorrs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIF ; ; Find (integer) sampling interval ; skip = 1iskip = GetKeyWord('skip', extra)IF(TypeOf(iskip) NE 7) THEN skip = FIX(iskip) > 1;; Form locally normalized (such that rms value is locally 1); copy of self;normedSelf = selflocalNorm=0locNorm = GetKeyWord('LocalNorm', extra)IF (TypeOf(locNorm) NE 7) THEN localNorm = locNormIF KEYWORD_SET(localNorm) THEN BEGIN	normedSelf = self -> LocalNorm(axis)ENDIF;; Check for 'fraction' keyword;fraction=0.5fract = GetKeyWord('fraction', extra)IF(TypeOF(fract) NE 7) THEN fraction=fract;; Check for 'debug' flag;debug=0dbug = GetKeyWord('debug', extra)IF(TypeOf(dbug) NE 7) THEN debug=dbug;; Create GKV structure to hold result,; and copy fields from 'self' to 'result';result = {GKVs1D}						FOR i=0, N_TAGS(result) - 1 DO 	$	result.(i) = self.(i)	;; Get grid structure corresponding to ; the inhomogeneous independent variable;axisString = STRING(axis, FORMAT='(I1)')commandString = 'grid = normedSelf.Grid' + axisStringok = EXECUTE(commandString)IF NOT ok THEN BEGIN	MESSAGE, "Could not extract inhomogeneous Grid Structure:  ", /INFORMATIONAL	MESSAGE, "Command String = " + commandString, /INFORMATIONAL	RETURN, 0ENDIF	oldGridValues = *Grid.values;; Set up loop over inhomogeneous independent variable;gridTitle = Grid.titlegridMnemonic = Grid.mnemonicirange = Grid.irangeimax = irange[1]-irange[0] nPoints = (imax +1)/skipvalues = FLTARR(nPoints)newGridValues = FLTARR(nPoints)values = FLTARR(nPoints)errors = FLTARR(nPoints)vPhase = FLTARR(nPoints)vPhaseErrors = FLTARR(nPoints)yValues = FLTARR(nPoints)yErrors = FLTARR(nPoints)kValues = FLTARR(nPoints)kErrors = FLTARR(nPoints)CorrObjs = OBJARR(nPoints)yCorrObjs = OBJARR(nPoints)kSpectObjs = OBJARR(nPoints);; Begin loop over inhomogeneous independent variable;FOR i=0, nPoints-1 DO BEGIN						; 'i' is index into 'result' arrays, while 'index' is the  	index = irange[0]+i*skip						; index to the inhomogeneous independent variable of 'self'. 	newGridValues[i] = oldGridValues[index]			; 	Set new grid values	tempObj = normedSelf -> Slice(axis=axis, index=index)	;	Slice 'normedSelf' at current value of inhomogeneous variable			tempcorrs = tempObj -> XCorr()					;	Compute local auto-correlation function	tempSpect = tempObj -> XSpect()					;	Compute local spectral density	; 	; Slice vs. tau along the maximum of spatial separation in the remaining (homogeneous) spatial coordinate.	;	tempCorrsmax = tempCorrs -> Slice(axis=1, /max, /maxlocation)	;	; Slice vs. homogeneous coordinate at tau=0.	;	tempCorrs1 = tempCorrs -> Slice(tau=0.)	tempCorrs0 = tempCorrs1 -> Execute("FLOAT")	tempCorrs2 = tempCorrs1 -> Envelope()	tempCorrs3 = tempCorrs2 -> Execute("FLOAT")	tempCorrs1 -> Trash	tempCorrs2 -> Trash	;	; Compute full width at 1/2 maximum (and associate error bars)	;	values[i] = tempCorrsmax.slice -> FullWidth(debug=debug, Error=localError, Fraction=fraction)	errors[i] = localError	yValues[i] = tempCorrs3 -> FullWidth(debug=debug, Error=yError, Fraction=fraction)	yErrors[i] = yError	tempCorrs3 -> Trash	;	; Compute mean k-value and width	;	kSpect = tempSpect -> Avg(axis="omega")	; *** REPLACE 'AVG' WITH 'INT' ONCE WE HAVE A RELIABLE 'INT' ***	kSpect -> Get, axis=1, Range=kRange	kRange[0] = 0.	kStats = kSpect -> Moments(axis=1, Range=kRange, /Avg)	kValues[i] = kStats[1] -> GetValues()	kerrors[i] = kStats[1] -> GetErrors()	;	; Compute phase velocity (and associate error bars)	;	tempCorrsmax.maxlocation -> SignalWindow, tau=[-values[i]/2., values[i]/2.]	vPhase[i] = tempcorrsmax.maxlocation -> slope(error=error)	vPhaseErrors[i] = error	; 	; Provide some output if requested	;	IF(KEYWORD_SET(debug)) THEN BEGIN		print, index, newGridValues[i], values[i], errors[i], vPhase[i], vPhaseErrors[i]		IF(i EQ 0) THEN tempCorrsMax.slice -> draw, /pretty ELSE tempCorrsMax.slice -> oplot	ENDIF	;	; Clean up temporary objects 	;	tempObj    -> Trash	tempcorrs  -> Trash	tempcorrsmax.maxlocation -> Trash	tempSpect -> Trash	;	; Save local correlation info	;	yCorrObjs[i]=tempCorrs0	CorrObjs[i]=tempCorrsMax.slice	kSpectObjs[i]=kSpectENDFOR;; Clean up normedSelf if necessary;IF KEYWORD_SET(localNorm) THEN BEGIN	normedSelf -> TrashENDIF;; Set fields of output Grid structure;Grid.values = PTR_NEW(newGridValues)Grid.uniform = GKVsd_UniformGrid(newGridValues)IF( (Grid.irange[0] NE 0) OR (Grid.irange[1] NE (N_ELEMENTS(oldGridValues)-1)) ) THEN Grid.boundary = 'open'xmin = MIN(newGridValues, MAX=xmax)Grid.range  = [xmin,xmax]Grid.irange = [0,nPoints-1];; Set fields of 'result' structure (containing taucorr vs. inhomogeneous coordinate);axisMnemonic = Grid.mnemonicaxisTitle = Grid.titleresult.mnemonic = 'tau_corr'result.title = '!4s!X!Lc!N {' + self.title + '}'CASE axis OF								;	1:	indices = Self -> IndexRemove([2,3])			; Remove 'indices' corresponding to	2:	indices = Self -> IndexRemove([1,3])			; the homogeneous independent variables	3:	indices = Self -> IndexRemove([1,2])			; ENDCASEresult.indices = PTR_NEW(indices)result.units = Grid.unitsresult.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)result.vrange = [0.0, vmax]result.ErrorBars = PTR_NEW(errors)result.Grid1 = Grid;; register 'result' as a GKVs1D object;tauCorrObj = OBJ_NEW('GKVs1D', result);; Now make a vPhase object;vPhaseObj = taucorrObj -> MakeCopy(/noValues, /noErrorBars)vPhaseObj.values = PTR_NEW(vPhase)vmin = GKVsd_MIN(vPhase, Max=vmax)vPhaseObj.vrange=[vmin, vmax]vPhaseObj.title = 'V!I!4u!N!X'vPhaseObj.mnemonic = 'v_phase'CASE axis OF	1:	units = self.Grid2.units + '/' + self.grid3.units	2:	units = self.Grid1.units + '/' + self.grid3.units		3:	units = self.Grid1.units + '/' + self.grid2.unitsENDCASEvPhaseObj.units = unitsvPhaseObj.ErrorBars = PTR_NEW(vPhaseErrors);; Now make a yCorr object;yCorrObj = taucorrObj -> MakeCopy(/noValues, /noErrorBars)yCorrObj.values = PTR_NEW(yValues)vmin = GKVsd_MIN(yValues, Max=vmax)yCorrObj.vrange=[0.0, vmax]CASE axis OF	1:	BEGIN			mnemonic = self.Grid2.mnemonic + "_corr"			title = "!12l!X" + SubScript(self.Grid2.title) + "!N"			units = self.Grid2.units		END	2:	BEGIN			mnemonic = self.Grid1.mnemonic + "_corr"			title = "!12l!X" + SubScript(self.Grid1.title) + "!N"			units = self.Grid1.units		END		3:	BEGIN			mnemonic = self.Grid1.mnemonic + "_corr"			title = "!12l!X" + SubScript(self.Grid1.title) + "!N"			units = self.Grid1.units		ENDENDCASEyCorrObj.title = titleyCorrObj.mnemonic = mnemonicyCorrObj.units = unitsyCorrObj.ErrorBars = PTR_NEW(yErrors);; Now make a kavg object;kAvgObj = taucorrObj -> MakeCopy(/noValues, /noErrorBars)kAvgObj.values = PTR_NEW(kValues)vmin = GKVsd_MIN(kValues, Max=vmax)vmin = vmin < 0.vmax = vmax > 1.kAvgObj.vrange=[vmin, vmax]CASE axis OF	1:	BEGIN			mnemonic = "k_" + self.Grid2.mnemonic			title = "k" + SubScript(self.Grid2.title) + "!N"			units = '1/(' + self.Grid2.units + ')'		END	2:	BEGIN			mnemonic = "k_" + self.Grid1.mnemonic			title = "k" + SubScript(self.Grid1.title) + "!N"			units = '1/(' + self.Grid1.units + ')'		END		3:	BEGIN			mnemonic = "k_" + self.Grid1.mnemonic			title = "k" + SubScript(self.Grid1.title) + "!N"			units = '1/(' + self.Grid1.units + ')'		ENDENDCASEkAvgObj.title = titlekAvgObj.mnemonic = mnemonickAvgObj.units = unitskAvgObj.ErrorBars = PTR_NEW(kErrors);; Now compute averages of local correlation info;kSpectObjs[0] -> get, title=kSpectTitle, mnemonic=kSpectMnemonickSpectTitle = '!12<!X' + kSpectTitle + '!12>!X' + SubScript(GridTitle) + "!N"kSpectMnemonic = 'Avg' + kSpectMnemonic + '_' + gridMnemonickSpectObj =  kSpectObjs[0] -> ObjAvg(kSpectObjs, title=kSpectTitle, mnemonic=kSpectMnemonic)corrObjs[0] -> get, title=corrFcnTitle, mnemonic=corrFcnMnemoniccorrFcnTitle = '!12<!X' + corrFcnTitle + '!12>!X' + SubScript(GridTitle) + "!N"corrFcnMnemonic = 'Avg' + corrFcnMnemonic + '_' + gridMnemoniccorrFcnObj =  corrObjs[0] -> ObjAvg(corrObjs, title=corrFcnTitle, mnemonic=corrFcnMnemonic)yCorrObjs[0] -> get, title=yCorrFcnTitle, mnemonic=yCorrFcnMnemonicyCorrFcnTitle = '!12<!X' + yCorrFcnTitle + '!12>!X' + SubScript(GridTitle) + "!N"yCorrFcnMnemonic = 'Avg' + ycorrFcnMnemonic + '_' + gridMnemonicyCorrFcnObj =  yCorrObjs[0] -> ObjAvg(yCorrObjs, title=yCorrFcnTitle, mnemonic=yCorrFcnMnemonic);; Construct output structure;output = {	Name	:	"TauCorrs", 	$		TauCorr	:	taucorrObj, 	$		vPhase	:	vPhaseObj, 	$		yCorr	:	ycorrObj, 	$		kAvg	:	kAvgObj, 	$		kSpect	:	kSpectObj,	$		corrFcn	:	corrFcnObj,	$		yCorrFcn:	yCorrFcnObj	};; Now, check for output keywords;IF(KEYWORD_SET(CorrFcnArr)) THEN BEGIN	output = CREATE_STRUCT(output, "CorrFcnArr", corrObjs)ENDIF ELSE BEGIN	GKVdelete, corrObjsENDELSEIF(KEYWORD_SET(yCorrFcnArr)) THEN BEGIN	output = CREATE_STRUCT(output, "yCorrFcnArr", yCorrObjs)ENDIF ELSE BEGIN	GKVdelete, yCorrObjsENDELSEIF(KEYWORD_SET(kSpectArr)) THEN BEGIN	output = CREATE_STRUCT(output, "kSpectArr", kSpectObjs)ENDIF ELSE BEGIN	GKVdelete, kSpectObjsENDELSE;; and we're done!;RETURN, output;END ; ****** GKVs3D::TauCorrs ****** ;