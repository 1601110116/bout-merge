FUNCTION GKVs3D::RCorrs, arg, CorrFcns=CorrObjs, _EXTRA=extra;; Purpose:;;		This function computes the correlation length;		(defined as the full width as half maximum of the;		two-point correlation function) of 'self' ;		(a GKVs3D object) as a function of the specified;		independent variable (which is assumed to be ;		inhomogeneous). If the system is homogeneous it ;		is ***MUCH*** more efficient to simply measure the ;		full width at half maximum of the correlation function;		obtained from Xcorr with no reference object.;;; Output:;;		GKVs3D::RCorrs returns a GKVs1D object containing the;		correlation length in the direction of the specified;		inhomogeneous coordinate vs. this coordinate.;;; Input Arguments:;;		GKVs3D::RCorrs will accept any legal axis identifier;		(that is, an integer between 1 and 3, or a valid;		axis mnemonic) as an argument.  If no argument is ;		provided, then GKVs3D::RCorrs will expect the axis;		corresponding to the inhomogeneous coordinate to be;		identified by keywords (see below). Optional;;; Output Arguments:;;		None;;;	Input Keywords:;;		Axis	If no argument is provided, then this keyword may be ;			used to identify Grid to be 'Restricted'. Set axis ;			equal to any legal axis identifier (see above).;			(optional);;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the selected independent ;			variable, and reset the signal window on this axis.;			This two-element array is interpreted as the desired RANGE in;			the independent variable (i.e., it is interpreted in the units;			of the corresponding independent variable), NOT the integer 'irange';			(that is, NOT as an integer index into the grid.values array).;			(optional);;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window of the selected independent variable.  The value of irange;			is interpreted as an index into the grid.values array.;			(optional);;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable.;			(optional);;		skip	The sampling interval for the specified inhomogeneous independent;			variable.  Defaults to 1 (Optional).;;	localNorm  Set this keyword (i.e., put '/LocalNorm' on the command line to normalize;			the data from 'self' (but not 'self' itself, whose data remains unaltered);			such that the rms fluctuation at each value of the specified inhomogeneous;			independent variable is the same BEFORE  computing the correlation length.;			Setting localNorm has the effect of removing the 'bias' in the computed;			correlation functions toward regions with high fluctuation values.  Resulting;			correlation length will now only reflect loss phase coherence.;;	    debug	Set this keyword (i.e., put '/debug' on the command line) to ;			print out intermediate information, allowing the user to keep track;			of the progress (or lack thereof...) of this function. ;			(optional);;	 fraction	Normally rcorrs returns the fullwidth at half maximum of the correlation;			function vs. the specified axis.  If this keyword is set, RCORR will ;			instead compute the full width at 'fraction' of maximum vs. the specified;			axis.  Defaults to 0.5 (Optional).;			;;;	Output Keywords:;;	 CorrFcns	If this keyword is included on the command line then, on return, ;			the corresponding symbol refer to an array of GKVs1D objects ;			containing the radial correlation function vs. r for each index;			at which the radial correlation length is computed.;			;;;; Side Effects:;;		Resets the signal window of 'self' to specified 'range' or irange if;		one is provided with any of the keywords 'mnemonic', irange, or range;	;; Written by W.M. Nevins;	9/25/00;FORWARD_FUNCTION GKVsd_MIN;; Get info from command line:;; First find identifier for axis corresponding to ; the inhomogeneous independent variable;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	ELSE	:	BEGIN				MESSAGE, 'RCorrs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIF ; ; Find (integer) sampling interval ; skip = 1iskip = GetKeyWord('skip', extra)IF(TypeOf(iskip) NE 7) THEN skip = FIX(iskip) > 1;; Form locally normalized (such that rms value is locally 1); copy of self;normedSelf = selflocalNorm=0locNorm = GetKeyWord('LocalNorm', extra)IF (TypeOf(locNorm) NE 7) THEN localNorm = locNormIF KEYWORD_SET(localNorm) THEN BEGIN	normedSelf = self -> LocalNorm(axis)ENDIF;; Check for 'fraction' keyword;fraction=0.5fract = GetKeyWord('fraction', extra)IF(TypeOF(fract) NE 7) THEN fraction=fract;; Check for 'debug' flag;debug=0dbug = GetKeyWord('debug', extra)IF(TypeOf(dbug) NE 7) THEN debug=dbug;; Create GKV structure to hold result,; and copy fields from 'self' to 'result';result = {GKVs1D}						FOR i=0, N_TAGS(result) - 1 DO 	$	result.(i) = self.(i)	;; Get grid structure corresponding to ; the inhomogeneous independent variable;axisString = STRING(axis, FORMAT='(I1)')commandString = 'grid = normedSelf.Grid' + axisStringok = EXECUTE(commandString)IF NOT ok THEN BEGIN	MESSAGE, "Could not extract inhomogeneous Grid Structure:  ", /INFORMATIONAL	MESSAGE, "Command String = " + commandString, /INFORMATIONAL	RETURN, 0ENDIF	oldGridValues = *Grid.values;; Set up loop over inhomogeneous independent variable;irange = Grid.irangeimax = irange[1]-irange[0] nPoints = (imax +1)/skipvalues = FLTARR(nPoints)newGridValues = FLTARR(nPoints)values = FLTARR(nPoints)errors = FLTARR(nPoints)IF( ARG_PRESENT(CorrObjs) ) THEN CorrObjs = OBJARR(nPoints);; Begin loop over inhomogeneous independent variable;FOR i=0, nPoints-1 DO BEGIN						; 'i' is index into 'result' arrays, while 'index' is the  	index = irange[0]+i*skip						; index to the inhomogeneous independent variable of 'self'. 	newGridValues[i] = oldGridValues[index]			; 	Set new grid values	tempObj = normedSelf -> Slice(axis=axis, index=index)	;	Slice 'normedSelf' at current value of inhomogeneous variable			tempcorrs = normedSelf -> XCorr(Ref=tempObj)		;	Take cross-correlation with 'self'	CASE axis OF									;		1:	BEGIN									; 'Slice' cross correlation function along 				temp1 = tempcorrs -> Slice(axis=3, /max)	; maximum of homogeneous variables, begining				temp2 = temp1     -> Slice(axis=2, /max)	; with the final (almost certianly 'tau', 			END									; that is time-lag) axis, and proceeding to 		2:	BEGIN									; remaining (persumalby homogeneous) spatial 				temp1 = tempcorrs -> Slice(axis=3, /max)	; variable.				temp2 = temp1     -> Slice(axis=1, /max)	;			END		3:	BEGIN				temp1 = tempcorrs -> Slice(axis=2, /max)				temp2 = temp1     -> Slice(axis=1, /max)			END		ELSE:	BEGIN				messageString =  'Invalid axis identifier:  ' + STRING(axis, FORMAT='(I1)')				MESSAGE, messageString, /INFORMATIONAL				RETURN, 0			END	ENDCASE	; 	; find full-width at half-maximum of the 'sliced' cross correlation function	;	values[i] = temp2 -> FullWidth(debug=debug, Error=localError, Fraction=fraction)	errors[i] = localError	IF(KEYWORD_SET(debug)) THEN BEGIN		print, index, newGridValues[i], values[i]		IF(i EQ 0) THEN temp2 -> draw, /pretty ELSE temp2 -> oplot	ENDIF	;	; Clean up temporary objects 	;	tempObj    -> Trash	tempcorrs  -> Trash	temp1      -> Trash	IF( ARG_PRESENT(CorrObjs) ) THEN BEGIN		CorrObjs[i]=temp2	ENDIF ELSE BEGIN		temp2 -> Trash	ENDELSE	; HEAP_GCENDFOR;; Set fields of output Grid structure;Grid.values = PTR_NEW(newGridValues)Grid.uniform = GKVsd_UniformGrid(newGridValues)IF( (Grid.irange[0] NE 0) OR (Grid.irange[1] NE (N_ELEMENTS(oldGridValues)-1)) ) THEN Grid.boundary = 'open'xmin = MIN(newGridValues, MAX=xmax)Grid.range  = [xmin,xmax]Grid.irange = [0,nPoints-1];; Set fields of 'result' structure;axisMnemonic = Grid.mnemonicaxisTitle = Grid.titleresult.mnemonic = axisMnemonic + '_corr'result.title = '!12l!X' + Subscript(axisTitle) + '!X!N{' + self.title + '}'CASE axis OF									;	1:	indices = Self -> IndexRemove([2,3])			; Remove 'indices' corresponding to	2:	indices = Self -> IndexRemove([1,3])			; the homogeneous independent variables	3:	indices = Self -> IndexRemove([1,2])			; ENDCASEresult.indices = PTR_NEW(indices)result.units = Grid.unitsresult.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)result.vrange = [vmin, vmax]result.ErrorBars = PTR_NEW(errors)result.Grid1 = Grid;; register 'result' as a GKVs1D object;RCorrObj = OBJ_NEW('GKVs1D', result);; Clean up normedSelf if necessary;IF KEYWORD_SET(localNorm) THEN BEGIN	normedSelf -> Trash	HEAP_GCENDIF;; and we're done!;RETURN, RcorrObj;END ; ****** GKVs3D::pg3eqTauCorrs ****** ;