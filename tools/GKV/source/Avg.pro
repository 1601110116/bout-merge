Pro GKVs1D::Smooth;; Apply '1:2:1' smoothing to 1-D data;temp = *self.valuesvalues = 0.25*(SHIFT(temp, -1) + 2.*temp + SHIFT(temp, 1))self.values = PTR_NEW(values)RETURNEND ; ****** GKVs1D::Smooth ****** ;Function GKVs1D::Avg,arg, _Extra=extra;; Purpose:;;		This function returns the average of 'self' over the selected;		independent variable.;;; 	Argument:;;			The (optional) argument is any legal axis identifier.;			That is, either an integer between 1 and nDims, or;			a STRING containing an axis mnemonic.;;	Keywords:;;	   Axis		If no argument is provided, then this keyword may be ;			used to identify independent variable with respect to ;			which the partial derivative is to be taken. Set axis ;			equal to any legal axis identifier (see above).;;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the independent variable;			for which the (partial) derivative is to be taken, and to ;			reset the signal window on this axis (before taking the derivative).;			This two-element array is interpreted as the desired RANGE in;			the independent variable, NOT the integer 'irange';;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window before taking the derivative w.r.t. the selected independent variable.;;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable over which the average ;			is to be taken.;			;			NoErrorBars  Set this keyword to insure that the returned object;			  has a null pointer for self.errorbars;		;;	Side Effects:;;			If a 'range' or 'irange' is specified on the command line ;			(either directly, or via 'mnemonic' = ...) then the ;			SignalWindow method will be invoked on 'self' and,;			on return, the signal window of the selected independent;			variable will have been modified.;; Written by W.M. Nevins;	6/18/00;; Revised by W.M. Nevins;	3/20/01;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	else	:	BEGIN				MESSAGE, 'DbyD called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIFresultStr = {GKVsd}FOR i=0, N_TAGS(resultStr)-1 DO resultStr.(i) = self.(i)axisString = STRING(axis, FORMAT='(I1)')commandString = 'Grid = self.Grid' + axisStringok = EXECUTE(commandString)values = *self.valuesinfo = SIZE(values)npoints = info[axis]irange = grid.irangeaxisTitle = grid.titleresultStr.Title = '!12<!X' + self.title + '!12>!X!D' + axisTitle  + '!N'newIndices = self -> IndexRemove(iaxis)resultStr.indices = PTR_NEW(newIndices);; Compute Average and standard deviation;dx = (*grid.values)[(irange[0]+1):irange[1]] - (*grid.values)[irange[0]:(irange[1]-1)]lx = ( (*grid.values)[irange[1]] - (*grid.values)[irange[0]] )values = 0.5*((*self.values)[(irange[0]+1):irange[1]] + (*self.values)[irange[0]:(irange[1]-1)]) avgValue   = TOTAL(values*dx)/lxavgValueSq = TOTAL(values*values*dx)/lxstd = SQRT(avgValueSq - avgValue^2);; Set up array of errors;errorBars = stdIF PTR_VALID(self.ErrorBars) THEN BEGIN	errors = 0.5*((*self.ErrorBars)[(irange[0]+1):irange[1]] + (*self.ErrorBars)[irange[0]:(irange[1]-1)])	avgErrorSq = TOTAL(errors*errors*dx)/lx	errorBars = errorBars + SQRT(avgErrorSq)ENDIF;; Load results into 'result' structure;noErrorBars = 0thisResult = GetKeyWord("NoErrorBars", Extra)IF(Query_Integer(thisResult)) THEN NoErrorBars = thisResultresultStr.values = PTR_NEW(avgValue)IF(NoErrorBars eq 0) THEN resultStr.ErrorBars = PTR_NEW(errorBars)result = OBJ_NEW("GKVsd", resultStr)RETURN, resultEND ; ****** GKVs1D::Avg ****** ;		Function GKVs2D::Avg, arg, _Extra=extra;; Virtual keywords:	axis=iaxis, range, irange;; Where:;;	iaxis		is the number of the axis corresponding to the independent ;			variable which you wish to average over;;			OR iaxis is a string containing a valid axis mnemonic;;	range		is a 2-element array containing the minimum and maximum values;			of the independent variable which you wish to average over;			(defaults to range specified by self.irange);;	irange		is a 2-element array containing the (integer) indices of the;			minimum and maximum values of the indepent variable which you;			wish to average over (defaults to self.irange);; Can also set both the axis and range by entering:;;	'mnemonic' = [vmin, vmax];; where 'mnemonic' is a valid axis mnemonic, and [vmin, vmax] is the range of values you wish to ; average over.;; If the range requested is greater than that available, then the maximum available range will be employed.;; Find average of input over selected axis;; Written by W.M. Nevins;	6/18/00;nDims = self -> NumDims()IF(N_ELEMENTS(arg) NE 0) THEN BEGIN		; Get axis ID from 'arg' if one is present	iaxis = arg					;	if 'arg' is a string, try to match with a mnemonic	IF(TypeOF(arg) EQ 7) THEN iaxis = self -> AxisNumber(arg)								; Otherwise, get axis ID from keyword "Axis"	IF(NOT Query_Integer(axis)) THEN GOTO, tryagain	ENDIF ELSE BEGINtryagain:iaxis=0result = GetKeyWord('axis', extra)IF(Query_Integer(result)) THEN iaxis = result					; command line of form axis = axisnumberIF(typeOf(result) EQ 7)  THEN iaxis = self -> AxisNumber(result)	; command line of the form axis = 'mnemnic'ENDELSEresult = GetKeyWord('range', extra)IF(typeOf(result) NE 7) THEN range = resultresult = GetKeyWord('irange', extra)IF(typeOf(result) NE 7) THEN irange = resultIF(iaxis EQ 0)  THEN BEGIN					; 'iaxis' is not yet set, so try to get axis ID from 'extra'	IF(typeOf(extra) NE 8) THEN BEGIN		; 	No more unparsed keywords in Extra, so print error message and return.		MESSAGE, 'No Valid axis ID', /INFORMATIONAL		RETURN, 0	ENDIF	axisInfo = self -> GetAxis(extra)		; Check for command line of form 'mnemonic'=[min,max]	FOR i=0, nDims-1 DO BEGIN		iaxis = i+1		IF(typeOf(axisInfo.(i)) NE 7) THEN BEGIN			range = axisInfo.(i)			GOTO, DONE1		ENDIF	ENDFOR;; an axis mnemonic did not appear on the command line, so print error message and return;		MESSAGE, 'No Valid axis ID', /INFORMATIONAL		RETURN, 0ENDIFDONE1:;; Check for legal axis ID;IF(iaxis GT ndims) THEN BEGIN	MESSAGE, 'Bad axis ID', /INFORMATIONAL	RETURN, 0ENDIFaxisString = STRING(iaxis, FORMAT='(I1)')commandStr = 'grid = self.Grid' + axisString ok = EXECUTE(commandStr)axistitle = grid.title	IF(N_ELEMENTS(range) EQ 2) THEN BEGIN	imin = self -> AxisIndex(iaxis, range[0])	imax = self -> AxisIndex(iaxis, range[1])	irange = [imin, imax]ENDIF;; Make a GKVsND structure (with N=nDdims-1) to hold output information;CASE nDims OF	2	:	resultStr = {GKVs1D}	3	:	resultStr = {GKVs2D}	4	:	resultStr = {GKVs3D}	ELSE	:	BEGIN			MESSAGE, 'AVG only supports objects with Dimensionality less than or equal to 4', /INFORMATIONAL			RETURN, 0			ENDENDCASE;; Populate resultStr;nTags = N_TAGS(resultStr)FOR i=0,nTags-1 DO resultStr.(i) = self.(i)resultStr.Title = '!12<!X' + self.title + '!12>!X!D' + axisTitle  + '!N'newIndices = self -> IndexRemove(iaxis)resultStr.indices = PTR_NEW(newIndices)resultStr.vrange=[0.,0.];; Get index range within self.values for average;imin1 = self.grid1.irange[0]imax1 = self.grid1.irange[1]imin2 = self.grid2.irange[0]imax2 = self.grid2.irange[1]IF(nDims GT 2) THEN BEGIN	imin3 = self.grid3.irange[0]	imax3 = self.grid3.irange[1]	IF(nDims GT 3) THEN BEGIN		imin4 = self.grid4.irange[0]		imax4 = self.grid4.irange[1]	ENDIFENDIFIF(N_ELEMENTS(irange) EQ 2) THEN BEGIN	commandStr = 'imin' + axisString + ' = irange[0]'	ok = EXECUTE(commandStr)	commandStr = 'imax' + axisString + ' = irange[1]'	ok = EXECUTE(commandStr)ENDIF;; Compute number of points to be averaged over;iirange = grid.irangeIF(N_ELEMENTS(irange) EQ 2) THEN iirange = irangenpoints = iirange[1] - iirange[0] + 1;; Compute Average;CASE nDims OF	2	:	values = TOTAL((*self.values)[imin1:imax1, imin2:imax2], iaxis)/npoints	3	:	values = TOTAL((*self.values)[imin1:imax1, imin2:imax2, imin3:imax3], iaxis)/npoints	4	:	values = TOTAL((*self.values)[imin1:imax1, imin2:imax2, imin3:imax3, imin4:imax4], iaxis)/npointsENDCASEresultStr.values = PTR_NEW(values);; Set Grid ;thisAxis=1FOR jaxis = 1, ndims DO BEGIN	IF(jAxis EQ iaxis) THEN GOTO, DONE2	thisString = STRING(thisaxis, FORMAT='(i1)')	jString = STRING(jaxis, FORMAT='(i1)')	commandStr = 'resultStr.Grid' + thisString + ' = GKVsd_GridCopy(self.Grid' + jString + ', Irange=[imin' + jString + ', imax' + jString + '])'	ok = EXECUTE(commandStr)	thisAxis = thisAxis + 1	DONE2:	ENDFOR;; Create output object;CASE nDims OF	2	:	result = OBJ_NEW('GKVs1D', resultStr)	3	:	result = OBJ_NEW('GKVs2D', resultStr)	4	:	result = OBJ_NEW('GKVs3D', resultStr)ENDCASERETURN, resultEND ; ****** GKVs2D::Avg ****** ;		