;; *****************************************************************************************************************; ******************************************     Copyright Notice     *********************************************; *                                                                                                               *; *  This work was produced at the University of California, Lawrence Livermore National Laboratory (UC LLNL)     *; *  under contract no. W-7405-ENG-48 (Contract 48) between the U.S. Department of Energy (DOE) and The Regents   *; *  of the University of California (University) for the operation of UC LLNL. Copyright is reserved to the      *; *  University for purposes of controlled dissemination, commercialization through formal licensing, or other    *; *  disposition under terms of Contract 48; DOE policies, regulations and orders; and U.S. statutes. The rights  *; *  of the Federal Government are reserved under Contract 48 subject to the restrictions agreed upon by the DOE  * ; *  and University as allowed under DOE Acquisition Letter 97-1.                                                 *; *                                                                                                               *; *****************************************************************************************************************;; *****************************************************************************************************************; **********************************************     DISCLAIMER     ***********************************************; *                                                                                                               *; *  This work was prepared as an account of work sponsored by an agency of the United States Government.         *; *  Neither the United States Government nor the University of California nor any of their employees, makes      *; *  any warranty, express or implied, or assumes any liability or responsibility for the accuracy, completeness, *; *  or usefulness  *of any information, apparatus, product, or process disclosed, or represents that its use     *; *  would not infringe privately-owned rights.  Reference herein to any specific commercial products, process,   *; *  or service by trade name, trademark, manufacturer or otherwise does not necessarily constitute or imply its  *; *  endorsement, recommendation, or favoring by the United States Government or the University of California.    *; *  The views and opinions of authors expressed herein do not necessarily state or reflect those of the United   *; *  States Government or the University of California, and shall not be used for advertising or product          *; *  endorsement purposes.                                                                                        *; *                                                                                                               *; *****************************************************************************************************************;PRO Trend_line, TIME, INPUT, SLOPE=AA, OFF_SET=BB, STD=SS, AVG=avg_val, 	$			Weights=wts, $			PMSLOPE = aa_error, PMOFFSET = bb_error, LINESPM = errorlines, DEBUG=d;; Perform least squares fit of INPUT vs. TIME:; (note that the TIME array does NOT have to be uniformly spaced);; 	INPUT ~= AA*Time + BB;; where;	;	AA is the slope of the line that minimizes the squared deviations;	aa_error is the (±) change in the slope which doubles the squared deviations;	(with offset re-adjusted to minimize squared deviations at slope = AA ± aa_error);	BB is the offset of the line that minimizes the squared deviations;	bb_error is the (±) change in the offset which doubles the squared deviations;	(with the slope re-adjusted to minimize squared deviations at offset = BB ± bb_error);	STD is standard deviation of INPUT from this fit;	The slope and offset of each of the four extremal lines are packed in the array;	errorlines, with the slope in errorlines[0,*] and the offset in errorlines[1,*];	AVG is the avearge value of INPUT;nargs = N_PARAMS()if (nargs gt 2) then begin	print, "ERROR in Trend_Line: Called with too many parameters"	returnendifif (nargs eq 0) then begin	print, "ERROR in Trend_Line: Called with too few parameters"	returnendifif (nargs eq 1) then begin; assume that argument is signal, take time step to be 1	temp = Time	info=SIZE(Time)	ndims=info(0)	if(ndims eq 0) then begin		print, "ERROR in Trend_Line:  Input is scalar or undefined"		return	endif	nt=info(ndims)	T=dindgen(nt)endifif (nargs eq 2) then begin	temp=input	info=SIZE(Input)	ndims=info(0)	if(ndims eq 0) then begin		print, "ERROR in Trend_Line:  Input is scalar or undefined"		return	endif	nt=info(ndims)	T=Window_Fcn(nt, 0)*TIME  ; zero out any extra values in "TIME" arrayendifweights = REPLICATE(1.0, nt)IF KEYWORD_SET(wts) THEN BEGIN	IF(N_ELEMENTS(wts) NE nt) THEN BEGIN		MESSAGE, 'N_ELEMENTS(weigths) NE N_ELEMENTS(signal), setting weights to 1', /INFORMATIONAL	ENDIF ELSE BEGIN		weights=wts	ENDELSEENDIFtotalWeight = TOTAL(weights);; Patch to deal with multi-dimensional arrays.  Goal is to find trend in TIME ONLY,; (it is assumed that the final index of INPUT array corresponds to TIME); assuming that data is homogeneous in remaining co-ordinate(s)...so we sum; Input array (now stored in temp) over any remaining dimensions;dims=info(0:ndims)dim=1tempsq=temp*tempwhile dim lt ndims DO begin	temp=TOTAL(temp,1)/dims(dim)	tempsq=TOTAL(tempsq,1)/dims(dim)	dim=dim+1endwhile;; compute average, trend ;avg_val = TOTAL(temp*weights)/totalweightavg_val_sq = TOTAL(tempsq*weights)/totalWeightavg_val_t = TOTAL(temp*t*weights)/totalWeightavg_t = TOTAL(t*weights)/totalWeightavg_t_sq = TOTAL(t*t*weights)/totalWeightaa  = (avg_val_t - avg_val*avg_t)/(avg_t_sq - avg_t^2)bb  = avg_val - aa*avg_tss=avg_val_sq - 2.0d*(aa*avg_val_t + bb*avg_val) + (aa^2)*avg_t_sq + 2.0d*aa*bb*avg_t + bb^2ss = ss > 0.ss=sqrt(ss)aa_error = ss/sqrt(avg_t_sq - avg_t^2) bb_error = ss*sqrt(avg_t_sq/(avg_t_sq - avg_t^2))errorlines=[aa+aa_error, bb-aa_error*avg_t]errorlines=[[errorlines],[aa-aa_error, bb+aa_error*avg_t]]errorlines=[[errorlines],[aa-bb_error*avg_t/avg_t_sq,bb+bb_error]]errorlines=[[errorlines],[aa+bb_error*avg_t/avg_t_sq,bb-bb_error]]if KEYWORD_SET(d) then begin	print, "Average = ", avg_val	print, "  Trend = ", aa, " ±", aa_error	print, " Offset = ", bb, " ±", bb_error	Print, "    STD = ", ss	plot, time, input	for i=0,3 do oplot, time, (errorlines[0,i]*time+errorlines[1,i]), linestyle=i+1endifreturnENDPRO GKVs1D::Find_Curve, xxx, yyy, W=weights, Avg=y_avg, STD=st_deviation, Output=out, Xlog=xlog, Ylog=ylog, $			_EXTRA=e, Gaussian=gaussian, xrange=x_range, yrange=y_range;  Display data for selection of subset to be fit;Ndims = self -> NumDims()IF( Ndims NE 1 ) THEN BEGIN	MESSAGE, 'FIND_SLOPE only implimented for GKVs1D objects', /Informational	RETURNENDIFGrid=self.Grid1imin=Grid.irange[0]imax=Grid.irange[1]xxx = (*Grid.values)[imin:imax]yyy = (*self.values)[imin:imax]xinfo=size(xxx)yinfo=size(yyy)if( xinfo(0) ne 1 ) then begin	PRINT, "ERROR in FIND_Curve: Abscissa has wrong dimensinality"	returnendifif( yinfo(0) ne 1) then begin	PRINT, "ERROR in FIND_Curve: Ordinate has wrong dimensionality"	returnendifxsize = xinfo(1)ysize = yinfo(1)n_elements=min(xsize, ysize)w=replicate(1.0, n_elements)IF KEYWORD_SET(weights) THEN BEGIN	w=weightsENDIF ELSE BEGINIF(PTR_VALID(self.errorBars)) THEN BEGIN	w=1./(*self.errorBars)^2ENDIFENDELSE;; Set plot defaults;xrange=self.Grid1.rangeif KEYWORD_SET(x_range) THEN xrange=x_rangetitle = self.MnemonicIF N_ELEMENTS(pretty)		THEN title = self.titleIF KEYWORD_SET(T_title)	THEN title=T_titlexstyle=1IF N_ELEMENTS(x_style) THEN xstyle=x_stylex_title = self.Grid1.mnemonic + " (" + self.Grid1.units + ")"IF N_ELEMENTS(pretty)		THEN x_title = self.Grid1.title + " (" + self.Grid1.units + ")"if KEYWORD_SET(x_title) 	THEN xtitle=x_titleytitle = "(" + self.units + ")"if KEYWORD_SET(y_title) THEN ytitle=y_titleyrange = self.vrangeif KEYWORD_SET(y_range) THEN yrange=y_range;;  Display data ;WINDOW, /FREE, /PIXMAP, 	$		; create a pixmap window	XSize=500, YSize=500pixwindow = !D.WINDOW				; Save pixmap window IDself -> draw, xlog=xlog, ylog=ylog, 				$	; PLOT, xxx, yyy,	xrange=xrange, xstyle=xstyle, title=title,		$	; position=[0.15, 0.15, 0.9, 0.9],	xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$	_Extra=extra 								; Plot data in pixmap window							; Create a display windowWINDOW, /FREE, XSize=500, YSize=500, Title='GKV:  Find_Curve'  dispwindow=!D.WINDOW				; Save display window IDDEVICE, 				$		;copy plot to display window	COPY=[ 0, 0, 500, 500, 0, 0, pixwindow];; Select data to be fit using "rubber-band box controlled ; by the MOUSE.; ; Get top (bottom) center of "rubber-band" box ;CURSOR, x2, y2, /DATA, /DOWN		; Get cursor locationx=fltarr(5)					; Create x and y arraysy=fltarr(5)					;  (which hold corners of "rubber-band" box)x(2) = x2						; Store co-ordinates of first box cornery(2) = y2						;  in 2nd element of x, y arrays!MOUSE.BUTTON=1					; Set mouse button to 1 ("left" mouse button);; Set up loop to both get bottom (top) corner of box (using left mouse button); AND to correct location of top (bottom) center of box ; (using center mouse button--"option" click on MAC) if necessary.; Loop ends upon pushing right mouse button ("apple" click on MAC).;REPEAT BEGIN					; Begin loop for "rubber-band" boxCURSOR, xc, yc, /DATA, /WAIT		; Get (tenative) bottom (top) corner of "rubber-band" boxx(!MOUSE.BUTTON) = xc				; Store location in x, y  arraysy(!MOUSE.BUTTON) = ycdelta_x=x(1)-x(2)				; Compute half-width of "rubber-band" boxx_right = x(1)					; Right corner is in x(1)				x_left = x(1) - 2.*delta_x			; Compute x-location of left cornerDEVICE, COPY=[0,0,500,500,0,0,pixwindow]	; erase old box	PlotS,	[x(1),x(1),x_left,x_left,x(1)], $	; draw new box		[y(1),y(2),y(2),y(1),y(1)];; Compute parabola which fills box;xpps = x(2) - delta_x + (delta_x/10.)*findgen(21)ypps=  y(2) - (y(2) - y(1))*((xpps-x(2))/delta_x)^2oplot, xpps, ypps, linestyle=1;ENDREP UNTIL !MOUSE.BUTTON eq 4		; Click right mouse button ("apple-click" on MAC)							; to end loop.; Find lower, upper indices of data ; to be fit with line.;ixup=SORT(xxx(0:n_elements-1))xmin=x(2) - ABS(delta_x)xmax=x(2) + ABS(delta_x)imin=-1imax=0for imin=0,n_elements-3 do begin	; Locate index of smallest element of xxx  which is >/= xmin	if( xxx(ixup(imin)) ge xmin ) then goto, DONE1endforDONE1:	$for imax=0, n_elements-2 do begin	; Locate index of largest element of xxx which is </= xmax	if( xxx(ixup(imax)) gt xmax ) then goto, DONE2endfor		imax = imax + 1DONE2:	imax = imax - 1xx=float(xxx(ixup(imin:imax)))yy=float(yyy(ixup(imin:imax)))ww=W(ixup(imin:imax))if KEYWORD_SET(Gaussian) then begin		; Fit selected data to a Gaussian, A(0*exp(-0.5*((x-A(1)/A(2))^2)Aest=fltarr(3)						; Array for extimates of Gaussian paramteresAest(0) = y(2)						; Estimated maximum valueAest(1) = x(2)						; Estimated centerAest(2) = delta_x*SQRT(0.5*y(2)/(y(2)-y(1)))	; Estimated half-widthyfit = GAUSSFIT(xx, yy, A, Nterms=3, Estimates=Aest)Max_value = A(0)x_max = A(1)x_width = A(2)d2bydx2 = -A(0)/(A(2)^2)y_plus = max_value*exp(-0.5)y_zero = max_value/10.sigma = !VALUES.F_NaNgoto, donefitendifif KEYWORD_SET(Xlog) then xx=alog(xx)if KEYWORD_SET(Ylog) then yy=alog(yy);; xx, yy now contain data selected by the "rubber=band"; with xx array in ascending order.; We now perform least-squares fit of this data to a parabola.;coefficients = POLYFITW(xx, yy, ww, 2, yfit, yband, sigma);; Compute maximum (of best fit), width, etc.;x_max = float(-0.5*coefficients(1)/coefficients(2))max_value = float(coefficients(0) + coefficients(1)*x_max + coefficients(2)*x_max^2)x_width = SQRT(float(-0.5*Max_value/coefficients(2)))y_plus = 0.5*Max_valuey_zero = 0.d2bydx2 = float(2.*coefficients(2))sigma=float(sigma)if KEYWORD_SET(ylog) then begin	max_value = exp(max_value)	x_width = SQRT(float(-0.5/coefficients(2)))	y_plus = max_value*exp(-0.5)	y_zero = max_value/100.	d2bydx2 = -Max_value/x_width^2	sigma = float(exp(sigma) - 1)endif	;; Now plot the bets fit parabola and the error band into pixmap window;donefit:	WSET, pixwindowxxp = xxyyp = yfit;yyplus = yfit + yband;yyminus= yfit - ybandif KEYWORD_SET(Gaussian) then begin	xpps=xxx	ypps=A(0)*exp(-0.5*((xpps-A(1))/A(2))^2)endif else begin	xpps = x_max + sqrt(2.)*x_width*(0.1*findgen(21) - 1.0)	ypps = coefficients(0) + xpps*coefficients(1) + xpps^2*coefficients(2)	if KEYWORD_SET(Ylog) then begin		yyp = exp(yyp)		;yyplus = exp(yyplus)		;yyminus= exp(yyminus)		ypps = exp(ypps)	endif	if KEYWORD_SET(Xlog) then begin		xxp = exp(xxp)		x_max = exp(x_max)		x_width = exp(x_width)		xpps = exp(xpps)	endifendelseoplot, xxp, yyp, THICK=2.					; Plot best fit with thick line.;oplot, xxp, yyplus,  linestyle=2			; Show best fit ± errors ;oplot, xxp, yyminus, linestyle=2			; with dashed lines.oplot, xpps, ypps						; Extend best fit to zero linePlots, [x_max, x_max], [y_zero, max_value]		; Draw centerline of parabolaPlots, [x_max+x_width, x_max+x_width]		 $	; Draw half-width line 	, [       y_plus,        y_zero]Arrow, x_max, y_plus, x_max+x_width, y_plus, /data	; Draw arrows to indicateArrow, x_max+x_width, y_plus, x_max, y_plus, /data	; half-width of parabola	;; Now write max value, x_max, x_width onto screen;String1=STRING( Format='(A, G10.4, A)',	"Maximum = ", max_value, "!C",	$								"         ±", sigma,  "!C!C",	$								"  x_max = ", x_max,  "!C!C",	$								" !4D!Xx = ", x_width,"!C!C",	$					" !9D!X!U2!N/!9D!Xx!U2!N = ", d2bydx2)If KEYWORD_SET(ylog) then string1(1) = String( format='(A10, G10.4, A6)', " ±", 100*sigma, "%!C!C")string1(1) = "  "+ string1(1)string1(2) = " " + string1(2)string1(3) = "      " + string1(3)string2=""for i=0,4 do string2=string2+string1(i)XYOUTS, x(4), y(4), String2, /DATA;; Copy results into display window;Wset, dispwindowDEVICE, COPY=[0,0,500,500,0,0,pixwindow]WDelete, pixwindow						; Delete pixmap window;; Make output if required;if(KEYWORD_SET(out)) then begin	base = WIDGET_BASE()	deviceKeywords = PS_FORM(cancel=canceled, parent=base)	if NOT canceled THEN BEGIN		currentDevice = !D.NAME		Set_Plot, 'PS'		Device, _Extra = deviceKeywords		self -> draw, xlog=xlog, ylog=ylog, 					$				xrange=xrange, xstyle=xstyle, title=title,		$					xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$				_Extra=extra 								; Plot data to PS device		oplot, xxp, yyp, THICK=2.					; Plot best fit parabola to PS device with thick line.		;oplot, xxp, yyplus,  linestyle=2			; Plot best fit ± standard deviation to PS device   		;oplot, xxp, yyminus, linestyle=2			; with dashed lines.		oplot, xpps, ypps						; Extend best fit to zero line		Plots, [x_max, x_max], [y_zero, max_value]		; Draw centerline of parabola to PS device		Plots, [x_max+x_width, x_max+x_width]		 $	; Draw half-width line  to PS device			, [       y_plus,        y_zero]		Arrow, x_max, y_plus, x_max+x_width, y_plus, /data	; Draw arrows to indicate		Arrow, x_max+x_width, y_plus, x_max, y_plus, /data	; half-width of parabola			XYOUTS, x(4), y(4), String2, /DATA			; Write maximum, x_max, x_width, etc. to postscript device		Device, /Close_file		Set_Plot, currentDevice	endif	endifreturnendPRO GKVs1D::Find_Avg, W=weights, Avg=y_avg, STD=st_deviation, Output=out, 	$				Xlog=xlog, Ylog=ylog, xrange=x_range, xstyle=x_style, 		$				title=T_title, xtitle=x_title,	ytitle=y_title, yrange=y_range, $				Pretty=pretty, _Extra=extra;  Display data for selection of subset to be averaged.;Ndims = self -> NumDims()IF( Ndims NE 1 ) THEN BEGIN	MESSAGE, 'FIND_SLOPE only implimented for GKVs1D objects', /Informational	RETURNENDIFGrid=self.Grid1imin=Grid.irange[0]imax=Grid.irange[1]xxx = (*Grid.values)[imin:imax]yyy = (*self.values)[imin:imax]xinfo=size(xxx)yinfo=size(yyy)if( xinfo(0) ne 1 ) then begin	PRINT, "ERROR in FIND_Avg: Abscissa has wrong dimensinality"	returnendifif( yinfo(0) ne 1) then begin	PRINT, "ERROR in FIND_Avg: Ordinate has wrong dimensionality"	returnendifxsize = xinfo(1)ysize = yinfo(1)n_elements=min(xsize, ysize)w=replicate(1.0, n_elements)IF KEYWORD_SET(weights) THEN BEGIN	w=weightsENDIF ELSE BEGINIF(PTR_VALID(self.errorBars)) THEN BEGIN	w=1./(*self.errorBars)^2ENDIFENDELSE;; Set plot defaults;xrange=self.Grid1.rangeif KEYWORD_SET(x_range) THEN xrange=x_rangetitle = self.MnemonicIF N_ELEMENTS(pretty)		THEN title = self.titleIF KEYWORD_SET(T_title)	THEN title=T_titlexstyle=1IF N_ELEMENTS(x_style) THEN xstyle=x_stylex_title = self.Grid1.mnemonic + " (" + self.Grid1.units + ")"IF N_ELEMENTS(pretty)		THEN x_title = self.Grid1.title + " (" + self.Grid1.units + ")"if KEYWORD_SET(x_title) 	THEN xtitle=x_titleytitle = "(" + self.units + ")"if KEYWORD_SET(y_title) THEN ytitle=y_titleyrange = self.vrangeif KEYWORD_SET(y_range) THEN yrange=y_range;;  Display data ;WINDOW, /FREE, /PIXMAP, 	$		; create a pixmap window	XSize=500, YSize=500pixwindow = !D.WINDOW				; Save pixmap window IDself -> draw, xlog=xlog, ylog=ylog, 				$	; PLOT, xxx, yyy,	xrange=xrange, xstyle=xstyle, title=title,		$	; position=[0.15, 0.15, 0.9, 0.9],	xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$	_Extra=extra 								; Plot data in pixmap window							; Create a display windowWINDOW, /FREE, XSize=500, YSize=500, Title='GKV:  Find_Avg'  dispwindow=!D.WINDOW				; Save display window IDDEVICE, 				$		;copy plot to display window	COPY=[ 0, 0, 500, 500, 0, 0, pixwindow];; Select data to be fit using "rubber-band box controlled ; by the MOUSE.; ; Get first corner of "rubber-band" box for ;CURSOR, x2, y2, /DATA, /DOWN		; Get cursor locationx=fltarr(5)					; Create x and y arraysy=fltarr(5)					;  (which hold corners of "rubber-band" box)x(2) = x2						; Store co-ordinates of first box cornery(2) = y2						;  in 2nd element of x, y arrays!MOUSE.BUTTON=1					; Set mouse button to 1 ("left" mouse button);; Set up loop to both get second corner of box (using left mouse button); AND to correct location of first corner ; (using center mouse button--"option" click on MAC) if necessary.; Loop ends upon pushing right mouse button ("apple" click on MAC).;REPEAT BEGIN					; Begin loop for "rubber-band" boxCURSOR, xc, yc, /DATA, /WAIT		; Get (tenative) second corner of "rubber-band" boxx(!MOUSE.BUTTON) = xc				; Store location in x, y  arraysy(!MOUSE.BUTTON) = ycDEVICE, 				$		; erase old box	COPY=[0,0,500,500,0,0,pixwindow]PlotS, [x(1),x(1),x(2),x(2),x(1)], $	; draw new box	[y(1),y(2),y(2),y(1),y(1)];ENDREP UNTIL !MOUSE.BUTTON eq 4		; Click right mouse button ("apple-click" on MAC)							; to end loop.; Find lower, upper indices of data ; to be fit with line.;ixup=SORT(xxx(0:n_elements-1))xmin=MIN(x(1:2))xmax=MAX(x(1:2))imin=-1imax=0for imin=0,n_elements-3 do begin	; Locate index of smallest element of xxx  which is >/= xmin	if( xxx(ixup(imin)) ge xmin ) then goto, DONE1endforDONE1:	$for imax=0, n_elements-2 do begin	; Locate index of largest element of xxx which is </= xmax	if( xxx(ixup(imax)) gt xmax ) then goto, DONE2endfor		imax = imax + 1DONE2:	imax = imax - 1xx=float(xxx(ixup(imin:imax)))yy=float(yyy(ixup(imin:imax)))ww=float(W(ixup(imin:imax)))if KEYWORD_SET(Xlog) then xx=alog(xx)if KEYWORD_SET(Ylog) then yy=alog(yy);; xx, yy now contain data selected by the "rubber=band"; with xx array in ascending order.;y_avg=total(ww*yy)/total(ww)y_sq_avg = total(ww*yy*yy)/total(ww)st_deviation = sqrt(y_sq_avg - y_avg^2);; We now perform least-squares fit of this data to a line.;Trend_line, xx, yy, Slope=AA, Off_Set=BB, pmslope=aa_error;; Now plot best average and standard deviation into pixmap window;WSET, pixwindowxxp = xxyyp = replicate(y_avg,imax-imin+1)yyplus = yyp + st_deviationyyminus= yyp - st_deviationyyline = AA*xx + BBif KEYWORD_SET(Ylog) then begin	yyp = exp(yyp)	yyplus = exp(yyplus)	yyminus= exp(yyminus)	yyline = exp(yyline)endifif KEYWORD_SET(Xlog) then xxp = exp(xxp)oplot, xxp, yyp, THICK=2.					; Plot average with thick line.oplot, xxp, yyplus,  linestyle=2			; Show y_avg ± standard deviation oplot, xxp, yyminus, linestyle=2			; with dashed lines.oplot, xxp, yyline,  linestyle=1			; Show linear best-fit as a dashed line;; Now write average, standard deviation, and trend to screen;if KEYWORD_SET(ylog) then begin	st_deviation = exp(st_deviation) - 1  ;  percentage error	y_avg=exp(y_avg)	endif	String1=STRING( Format='(A10, G10.4, A6)',	" Average =", y_avg, "!C",	$								" ±", st_deviation, "!C!C",	$								"Trend =", aa, "!C",	$								" ±", aa_error)If KEYWORD_SET(ylog) then string1(1) = String( format='(A10, G10.4, A6)', " ±", 100*st_deviation, "%!C!C")string2=""for i=0,3 do string2=string2+string1(i)XYOUTS, x(4), y(4), String2, /DATA;; Copy results into display window;Wset, dispwindowDEVICE, COPY=[0,0,500,500,0,0,pixwindow]WDelete, pixwindow						; Delete pixmap window;; Make output if required;if(KEYWORD_SET(out)) then begin	base = WIDGET_BASE()	deviceKeywords = PS_FORM(cancel=canceled, parent=base)	if NOT canceled THEN BEGIN		currentDevice = !D.NAME		Set_Plot, 'PS'		Device, _Extra = deviceKeywords		self -> draw, xlog=xlog, ylog=ylog, 					$	; PLOT, xxx, yyy, ...				xrange=xrange, xstyle=xstyle, title=title,		$					xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$				_Extra=extra 							 	; Plot data to PS device		oplot, xxp, yyp, THICK=2.					; Plot average to PS device with thick line.		oplot, xxp, yyplus,  linestyle=2			; Plot y_avg ± standard deviation to PS device   		oplot, xxp, yyminus, linestyle=2			; with dashed lines.		oplot, xxp, yyline,  linestyle=1			; Plot linear best-fit as a dashed line on PS device  		XYOUTS, x(4), y(4), String2, /DATA			; Write slope, error, etc. to postscript device		Device, /Close_file		Set_Plot, currentDevice	endif	endifreturnendPRO GKVs1D::Find_Slope, slope=aa, PMSlope = aa_error, XOut = x_rangeOut, Output=out, Xlog=xlog, Ylog=ylog, 			$			xrange=x_range, xstyle=x_style, title=T_title, xtitle=x_title,	$			ytitle=y_title, yrange=y_range, Pretty=pretty, LinearAnalysis=linearAnalysis, log=log, _Extra=extra;  Display data to be fit with a line;Ndims = self -> NumDims()IF( Ndims NE 1 ) THEN BEGIN	MESSAGE, 'FIND_SLOPE only implimented for GKVs1D objects', /Informational	RETURNENDIFGrid=self.Grid1imin=Grid.irange[0]imax=Grid.irange[1]xxx = (*Grid.values)[imin:imax]yyy = (*self.values)[imin:imax]xinfo=size(xxx)yinfo=size(yyy)if( xinfo(0) ne 1 ) then begin	PRINT, "ERROR in FIND_SLOPE: Abscissa has wrong dimensinality"	returnendifif( yinfo(0) ne 1) then begin	PRINT, "ERROR in FIND_SLOPE: Ordinate has wrong dimensionality"	returnendifxsize = xinfo(1)ysize = yinfo(1)n_elements=min(xsize, ysize);; Set plot defaults;xrange=self.Grid1.rangeif KEYWORD_SET(x_range) THEN xrange=x_rangeindices = self -> IndexString([0,1], pretty=pretty)indexStr = '[' + STRJOIN(indices, ', ') + ']'IF(KEYWORD_SET(pretty)) THEN BEGIN	title=self.title + indexStr + " (" + self.units + ")"ENDIF ELSE BEGIN	title=self.mnemonic + indexStr + " (" + self.units + ")"ENDELSEIF KEYWORD_SET(T_title) THEN title=T_titlexstyle=1IF N_ELEMENTS(x_style) THEN xstyle=x_stylex_title = self.Grid1.mnemonic + " (" + self.Grid1.units + ")"IF N_ELEMENTS(pretty)		THEN x_title = self.Grid1.title + " (" + self.Grid1.units + ")"if KEYWORD_SET(x_title) 	THEN xtitle=x_titleytitle = "(" + self.units + ")"if KEYWORD_SET(y_title) THEN ytitle=y_titleyrange = self.vrangeif KEYWORD_SET(y_range) THEN yrange=y_rangeIF KEYWORD_SET(linearAnalysis) THEN ylog=1IF KEYWORD_SET(log)  THEN ylog= logIF KEYWORD_SET(ylog) THEN  log=ylog;;  Display data to be fit with a line;WINDOW, /FREE, /PIXMAP, 	$		; create a pixmap window	XSize=500, YSize=500pixwindow = !D.WINDOW				; Save pixmap window IDself -> draw, xlog=xlog, log=log, 				$	; PLOT, xxx, yyy,	xrange=xrange, xstyle=xstyle, title=title,		$	; position=[0.15, 0.15, 0.9, 0.9],	xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$	_Extra=extra 	; Plot data in pixmap windowIF PTR_VALID(self.ErrorBars) THEN BEGIN				err=(*self.ErrorBars)[imin:imax]	ERRPLOT, xxx, yyy-err, yyy+err					; Add error bars if needed	oplot, xxx, yyy, psym=4					;	and symbol at data points	ENDIF														; Create a display windowWINDOW, /FREE, XSize=500, YSize=500, Title='GKV:  Find_Slope'  dispwindow=!D.WINDOW				; Save display window IDDEVICE, 				$		;copy plot to display window	COPY=[ 0, 0, 500, 500, 0, 0, pixwindow];; Select data to be fit using "rubber-band box controlled ; by the MOUSE.; ; Get first corner of "rubber-band" box for ;CURSOR, x2, y2, /DATA, /DOWN		; Get cursor locationx=fltarr(5)					; Create x and y arraysy=fltarr(5)					;  (which hold corners of "rubber-band" box)x(2) = x2						; Store co-ordinates of first box cornery(2) = y2						;  in 2nd element of x, y arrays!MOUSE.BUTTON=1					; Set mouse button to 1 ("left" mouse button);; Set up loop to both get second corner of box (using left mouse button); AND to correct location of first corner ; (using center mouse button--"option" click on MAC) if necessary.; Loop ends upon pushing right mouse button ("apple" click on MAC).;REPEAT BEGIN					; Begin loop for "rubber-band" boxCURSOR, xc, yc, /DATA, /WAIT		; Get (tenative) second corner of "rubber-band" boxx(!MOUSE.BUTTON) = xc				; Store location in x, y  arraysy(!MOUSE.BUTTON) = ycDEVICE, 				$		; erase old box	COPY=[0,0,500,500,0,0,pixwindow]PlotS, [x(1),x(1),x(2),x(2),x(1)], $	; draw new box	[y(1),y(2),y(2),y(1),y(1)];ENDREP UNTIL !MOUSE.BUTTON eq 4		; Click right mouse button ("apple-click" on MAC)							; to end loop.; Find lower, upper indices of data ; to be fit with line.;ixup=SORT(xxx(0:n_elements-1))xmin=MIN(x(1:2))xmax=MAX(x(1:2))imin=-1imax=0for imin=0,n_elements-3 do begin	if( xxx(ixup(imin)) ge xmin ) then goto, DONE1endforDONE1:	$for imax=0, n_elements-2 do begin	if( xxx(ixup(imax)) ge xmax ) then goto, DONE2endforDONE2:	$xx=float(xxx(ixup(imin:imax)))yy=yyy[ixup[imin:imax] ]save_yy = yynPoints = imax-imin+1ww = REPLICATE(1., nPoints)IF PTR_VALID(self.ErrorBars) THEN BEGIN	ww = err(ixup(imin:imax))			ENDIFif KEYWORD_SET(Xlog) then xx=alog(xx)if KEYWORD_SET(Ylog) then BEGIN	IF PTR_VALID(self.ErrorBars) THEN ww=ABS(ww/yy)	IF(NOT KEYWORD_SET(LinearAnalysis)) THEN yy=alog(ABS(yy))ENDIF;; xx, yy now contain data selected by the "rubber=band"; with xx array in ascending order.; We now perform least-squares fit of this data to a line.;IF KEYWORD_SET(linearAnalysis) THEN BEGIN	IF(Query_Complex(yy)) THEN BEGIN		Lnyy = ALOG(yy)		phase = IMAGINARY(Lnyy)		;		; make 'phase' continuous by removing 2pi phase shifts		;				shiftUp = (phase - SHIFT(phase, 1)) GT !PI		shiftUp[0] = 0		shiftDown = (phase - SHIFT(phase,1)) LT -!PI		shiftDown[0] = 0		netshift = FLOAT(shiftUp) - FLOAT(shiftDown)		shifts =2.*!PI*TOTAL(netShift, /CUMULATIVE)		phase = phase - shifts		;		; Find frequency... that is, the slope of 'phase'		;		Trend_line, xx, phase, weights=ww, Slope=omega, PMslope=PMomega		avgPeriod = 2.*!PI/omega		errPeriod = 2.*!PI*PMomega/omega^2		;		; now, find growth rate		;		LnAmplitude = FLOAT(Lnyy)		Trend_line, xx, LnAmplitude, weights=ww, Slope=AA, Off_Set=BB, PMslope = aa_error, PMoffset = bb_error, LinesPM = errorlines		growthRate=aa		PMgrowthRate = aa_error	ENDIF ELSE BEGIN		yy = FLOAT(yy)		yy = ABS(yy)		ww=ww*(yy GE SHIFT(yy,1))*(yy GE SHIFT(yy,-1))		ww[0]=0.		ww[nPoints-1]=0.		yymin = MIN(save_yy)		OPLOT, xx,   (ww GT 0)*save_yy, MIN_VALUE=yymin, color=2, PSYM=1		mins = (yy LE SHIFT(yy,1))*(yy LE SHIFT(yy,-1))		OPLOT, xx, (mins GT 0)*save_yy, MIN_VALUE=yymin, color=2, PSYM=4		nMins = TOTAL(mins)		minIndex = REVERSE(SORT(mins*xx))		tmin = FLTARR(nMins)		tmin = xx[minIndex[0:(nmins-1)]]			tmin = REVERSE(tmin)		periods = tmin - Shift(tmin,1)		avgPeriod1 = TOTAL(periods[1:(nMins-1)]/(nMins-1))		;		; Remove short peroids (persumably mistakes...)		;		FOR i=1,5 DO BEGIN			periods = periods*(periods GT avgPeriod1/2.)			nmins = TOTAL(periods GT 0)			avgPeriod1 = TOTAL(periods)/nMins		ENDFOR			nMin1 = TOTAL(periods GT avgPeriod1/2.)		avgPeriod = TOTAL(periods)/nMin1		errPeriod = 2.*SQRT(TOTAL(periods^2)/nMin1 - avgPeriod^2)		avgPeriod = 2.*avgPeriod		omega = 2.*!PI/avgPeriod		PMomega = 2.*!PI*errPeriod/avgPeriod^2		;		; Find maxima		;		maxs = (yy GT SHIFT(yy,1))*(yy GT SHIFT(yy,-1))		maxs[0] = 0		maxs[nPoints-1] = 0		nMax = TOTAL(maxs)		maxIndices = WHERE(maxs EQ 1b)		maxVals = yy[maxIndices]		maxLocs = xx[maxIndices]		Trend_line, maxLocs, maxVals, Slope=AA, Off_Set=BB, PMslope = aa_error, PMoffset = bb_error, LinesPM = errorlines		plotMins=1b	ENDELSEENDIF ELSE BEGIN	Trend_line, xx, yy, weights=ww, Slope=AA, Off_Set=BB, PMslope = aa_error, PMoffset = bb_error, LinesPM = errorlinesENDELSE;; Now plot best fit and errors into pixmap window;WSET, pixwindowxxp = xxyyp = aa*xx + bbIF(plotMins) THEN BEGIN	yyp = aa*maxLocs + bb	xxp = maxLocsENDIF ELSE BEGIN	if KEYWORD_SET(Ylog) then yyp = exp(yyp)	if KEYWORD_SET(Xlog) then xxp = exp(xxp)ENDELSEoplot, xxp, yyp, THICK=2.					; Plot best fit with thick lineFOR i=0,3 DO begin						; Loop over four error lines (±slope and ±offset)	yyp = errorlines(0,i)*xx+errorlines(1,i)		xxp = xx	IF(plotMins) THEN BEGIN		yyp = errorlines[0,i]*maxLocs + errorlines[1,i]		xxp = maxLocs	ENDIF ELSE BEGIN		if KEYWORD_SET(Ylog) then yyp = exp(yyp)		if KEYWORD_SET(Xlog) then xxp = exp(xxp)	ENDELSE	oplot, xxp, yyp, linestyle=1			; Show error lines as dashed linesendforIF KEYWORD_SET(plotMins) THEN BEGIN	OPLOT, xx,   (ww GT 0)*save_yy, MIN_VALUE=yymin, color=2, PSYM=1	OPLOT, xx, (mins GT 0)*save_yy, MIN_VALUE=yymin, color=2, PSYM=4ENDIF;; Now write slope, offset, and estimated uncertianties to screen;	String1=STRING( Format='(A8, G10.4, A6)',	" Slope =", aa, "!C",		$								" ±", aa_error, "!C!C",	$								"Offset =", bb, "!C",		$								" ±", bb_error, "!C" )string2=""for i=0,3 do string2=string2+string1(i)IF KEYWORD_SET(LinearAnalysis) THEN BEGIN	string3=STRING( FORMAT='(A8, G10.4, A6)',	"Period =", avgPeriod, "!C", $							      " ±", errPeriod, "!C")	string2 = string2 + "!C"	FOR i=0,1 DO string2 = string2 + string3[i]	string2=string2 + "!C"	string3=STRING( FORMAT='(A8, G10.4, A6)',	" Omega =", omega, "!C", $							      " ±", PMomega, "!C")	FOR i=0,1 DO string2 = string2 + string3[i]    ENDIFXYOUTS, x(4), y(4), String2, /DATA;; Copy results into display window;Wset, dispwindowDEVICE, COPY=[0,0,500,500,0,0,pixwindow]WDelete, pixwindow						; Delete pixmap window;; compute range of x values;x_min = MIN(xx, MAX=x_max)x_rangeOut = [x_min, x_max];; Make output if required;if(KEYWORD_SET(out)) then begin	base = WIDGET_BASE()	deviceKeywords = PS_FORM(cancel=canceled, parent=base)	if NOT canceled THEN BEGIN		currentDevice = !D.NAME		Set_Plot, 'PS'		Device, _Extra = deviceKeywords		self -> draw, xlog=xlog, ylog=ylog, 						$	; PLOT, xxx, yyy,					xrange=xrange, xstyle=xstyle, title=title,		$	; position=[0.15, 0.15, 0.9, 0.9],					xtitle=xtitle, ytitle=ytitle, yrange=yrange,	$					_Extra=extra 	; Plot data in pixmap window		IF PTR_VALID(self.ErrorBars) THEN BEGIN						err=(*self.ErrorBars)[imin:imax]			ERRPLOT, xxx, yyy-err, yyy+err					; Add error bars if needed			oplot, xxx, yyy, psym=4					;	and symbol at data points			ENDIF		xxp = xx								; Reset xxp, yyp arrays to		yyp = aa*xx + bb						; least-squares-fit line		if KEYWORD_SET(Ylog) then yyp = exp(yyp)		if KEYWORD_SET(Xlog) then xxp = exp(xxp)			oplot, xxp, yyp, THICK=2.				; Plot best fit with thick line on postscript device			FOR i=0,3 DO begin					; Loop over four error lines (±slope and ±offset)				yyp = errorlines(0,i)*xx+errorlines(1,i)					xxp = xx				if KEYWORD_SET(Ylog) then yyp = exp(yyp)				if KEYWORD_SET(Xlog) then xxp = exp(xxp)				oplot, xxp, yyp, linestyle=1		; Plot error lines on postscript device as dashed lines			endfor			XYOUTS, x(4), y(4), String2, /DATA		; Write slope, error, etc. to postscript device		Device, /Close_file		Set_Plot, currentDevice	endif	endifreturnend