Function GKVs1D::Coherence, arg;; Purpose:;;	GKVs1D::Coherence expects 'self' to contian a spectral density.;	It computes a 'coherence' from this spectral density in three ways:;;		C1 = (Int S(k,omega)Ln[S(k,omega)/(Int S(k,omega) dkdOmega)] dkdOmega)/(Int S(k,omega) dkdOmega);		C2 = (Int S(k,omega)^2 dkdOmega)/(Int S(k,omega) dkdOmega)^2;		C3 =  Ln(C2);; 	If 'arg' is absent, greater than 3, or less than zero then all three;	versions of the coherence are returned in an anonymous output structure.;;	If arg = 1, 2, or 3, then the corresponding version of the 'coherence';	is returned as a floating point number. ;;; Written by W.M. Neving;	5/29/02;FORWARD_FUNCTION GKVsd_MINValuePtr = self -> GetValues()values = *valuePtrPTR_FREE, valuePtrinfo = SIZE(values)nDim = info[0]nPoints = FLOAT(info[nDim+2])totValues = TOTAL(values)Norm = (1./totValues)arg1 = nPoints*Norm*values > 1.e-8C1 = Norm*TOTAL(values*ALOG(arg1))C2 = nPoints*(Norm^2)*TOTAL(Values^2)C3 = ALOG(C2)Result = { Name:'Coherence', C1:C1, C2:C2, C3:C3 }nArgs = N_PARAMS()IF(nArgs) THEN BEGIN	IF(Query_Integer(arg)) THEN BEGIN		arg = arg > 0		IF(arg GT 3) THEN arg = 0		CASE   arg OF			0:	RETURN, result			1:	RETURN, C1			2:	RETURN, C2			3:	RETURN, C3		ENDCASE	ENDIFENDIFRETURN, resultEND  ; ****** GKVs1D::Coherence ****** ;FUNCTION GKVs2D::CoherenceScan, arg, iCoh=iCoh, _Extra=Extra;; Purpose:;;	Compute coherence vs. specified independent variable;;; Input Arguments:;;		GKVs2D::CoherenceScan will accept any legal axis identifier;		(that is, an integer between 1 and 3, or a valid;		axis mnemonic) as an argument.  If no argument is ;		provided, then GKVs2D::CoherenceScan will expect the axis;		corresponding to the inhomogeneous coordinate to be;		identified by keywords (see below). (Optional);;;  Input Keywords:;;	     Axis	If no argument is provided, then this keyword may be ;			used to identify the inhomogeneous coordinate. Set axis ;			equal to any legal axis identifier (see above).;			(optional);;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the selected independent ;			variable, and reset the signal window on this axis.;			This two-element array is interpreted as the desired RANGE in;			the independent variable (i.e., it is interpreted in the units;			of the corresponding independent variable), NOT the integer 'irange';			(that is, NOT as an integer index into the grid.values array).;			(optional);;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window of the selected independent variable.  The value of irange;			is interpreted as an index into the grid.values array.  'irange';			defaults to the current signal window of 'self.;			(optional);;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable.;			(optional);;	     skip	The sampling interval for the specified inhomogeneous independent;			variable.  Defaults to 1 (Optional).;;	omegaMax	Maximum value of of frequency to consider. Defaults to;			maximum value in 'self'.  Results depend on choice of;			omegaMax, so think about your choice!  OmegaMax should;			be large enough to include all frequencies with appreciable;			spectral density, but should exclude large regions with;			no appreciable spectral density.  OmegaMax should be;			the SAME for all elements of a parameter scan among which;			you wish to compare the coherence.;;	   fMax		Use 'fMax' instead of omegaMax to set the maximum frequency;			in cycles/(time unit) instead of radians/(time unit). Otherwise;			identical to omegaMax above. ;;	   kMax		Maximum value of the wavenumber to consider.  Choose similarly;			to omegaMax as described above.;;   Output Structure Tags:;;	C1		A scan of C1 (an S*Log(S) measure of coherence) vs. selected independent;			variable.  At each value of the selected independent varialbe, ;			C1 is defined as:;;			C1 = (Int S(k,omega)Ln[S(k,omega)/(Int S(k,omega) dkdOmega)] dkdOmega)/(Int S(k,omega) dkdOmega);;	C2		A scan of C2 (an S^2 measure of coherence) vs. selected independent;			variable.  At each value of the selected independent varialbe, ;			C2 is defined as:;;			C2 = (Int S(k,omega)^2 dkdOmega)/(Int S(k,omega) dkdOmega)^2;;	C3		A scan of C3 (Log(S)^2 measure of coherence) vs. selected independent;			variable.  At each value of the selected independent varialbe, ;			C3 is defined as:;;			C3 =  Ln(C2);; Written by W.M. Nevins;	5/29/02;;; Get info from command line:;; First find identifier for axis corresponding to ; the inhomogeneous independent variable;CASE N_PARAMS() OF	0	:	axis = self -> AxisIrange(     _Extra=extra)	1	:	axis = self -> AxisIrange(arg, _Extra=extra)	ELSE	:	BEGIN				MESSAGE, 'tauCorrs called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIF;; Get number of dimensions;nDims = self -> NumDims();; Get omegaMax, kmax;result = GetKeyword('omegaMax', Extra)IF(TypeOf(result) NE 7) THEN omegaMax=resultresult = GetKeyWord('fMax', Extra)IF(TypeOF(result) NE 7) THEN omegaMax = 2.*!PI*resultresult = GetKeyWord('kMax', Extra)IF(TypeOf(result) NE 7) THEN kMax=result;; Find (integer) sampling interval; skip = 1iskip = GetKeyWord('skip', extra)IF(TypeOf(iskip) NE 7) THEN skip = FIX(iskip) > 1;; Create GKV structure to hold result,; and copy fields from 'self' to 'result';result = {GKVs1D}						FOR i=0, N_TAGS(result) - 1 DO 	$	result.(i) = self.(i)	;; Get grid structure corresponding to ; the inhomogeneous independent variable;axisString = STRING(axis, FORMAT='(I1)')commandString = 'grid = Self.Grid' + axisStringok = EXECUTE(commandString)IF NOT ok THEN BEGIN	MESSAGE, "Could not extract inhomogeneous Grid Structure:  ", /INFORMATIONAL	MESSAGE, "Command String = " + commandString, /INFORMATIONAL	RETURN, 0ENDIFIF(N_ELEMENTS(arg) EQ 0) THEN arg=Grid.mnemonic	oldGridValues = *Grid.values;;; Set up loop over inhomogeneous independent variable;gridTitle = Grid.titlegridMnemonic = Grid.mnemonicirange = Grid.irangeimax = irange[1]-irange[0] nPoints = (imax +1)/skipnewGridValues = FLTARR(nPoints)CohValues = FLTARR(nPoints, 4);; Begin loop over inhomogeneous independent variable;FOR i=0, nPoints-1 DO BEGIN						; 'i' is index into 'result' arrays, while 'index' is the  	index = irange[0]+i*skip					; index to the inhomogeneous independent variable of 'self'. 	newGridValues[i] = oldGridValues[index]				; 	Set new grid values	tempObj = Self -> Slice(axis=axis, index=index)			;	Slice 'Self' at current value of inhomogeneous variable			tempSpect = tempObj -> XSpect()					;	Compute local spectral density	CASE nDims OF		2:	IF(N_ELEMENTS(omegaMax) EQ 1) THEN 	$ 	;	set maximum frequency				tempSpect -> SignalWindow, axis=nDims-1, range=[-omegaMax, omegaMax]		3:	BEGIN			IF(N_ELEMENTS(omegaMax) EQ 1) THEN 	$ 	;	set maximum frequency				tempSpect -> SignalWindow, axis=nDims-1, range=[-omegaMax, omegaMax]			IF(N_ELEMENTS(    kMax) EQ 1) THEN	$	;	and wavenumber				tempSpect -> SignalWindow, axis=nDims-2, range=[-kMax, kMax]			END		4:	BEGIN			IF(N_ELEMENTS(omegaMax) EQ 1) THEN 	$ 	;	set maximum frequency				tempSpect -> SignalWindow, axis=nDims-1, range=[-omegaMax, omegaMax]			IF(N_ELEMENTS(    kMax) EQ 1) THEN	BEGIN	;	and wavenumbers				tempSpect -> SignalWindow, axis=nDims-2, range=[-kMax, kMax]				tempSpect -> SignalWindow, axis=nDims-3, range=[-kMax, kMax]				ENDIF							END	ENDCASE	tempCohStr = tempSpect -> Coherence()				;	Compute 'coherence' at this location	FOR j=1,3 DO cohValues[i,j] = tempCohStr.(j)			;	and store results in cohValues	tempObj   -> Trash						; Clean up	tempSpect -> TrashENDFOR;; Set fields of output Grid structure;Grid.values = PTR_NEW(newGridValues)Grid.uniform = GKVsd_UniformGrid(newGridValues)IF( (Grid.irange[0] NE 0) OR (Grid.irange[1] NE (N_ELEMENTS(oldGridValues)-1)) ) THEN Grid.boundary = 'open'xmin = MIN(newGridValues, MAX=xmax)Grid.range  = [xmin,xmax]Grid.irange = [0,nPoints-1];; Set fields of 'result' structure (containing taucorr vs. inhomogeneous coordinate);axisMnemonic = Grid.mnemonicaxisTitle = Grid.titleresult.mnemonic = 'C1'result.title = 'C!D1!N{' + self.title + '}'CASE axis OF								;	1:	indices = Self -> IndexRemove([2,3])			; Remove 'indices' corresponding to	2:	indices = Self -> IndexRemove([1,3])			; the homogeneous independent variables	3:	indices = Self -> IndexRemove([1,2])			; ENDCASEresult.indices = PTR_NEW(indices)result.units = ''values = cohValues[*,1]result.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)result.vrange = [0.0, vmax]result.ErrorBars = PTR_NEW()result.Grid1 = Grid;; register 'result' as a GKVs1D object;C1_Obj = OBJ_NEW('GKVs1D', result);; Now make C2 object ;C2_Obj = C1_Obj -> MakeCopy()C2_Obj.title = 'C!D2!N{' + self.title + '}'C2_Obj.mnemonic = 'C2'values = cohValues[*,2]C2_Obj.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)C2_Obj.vrange = [0, vmax];; and C3 object;C3_Obj = C1_Obj -> MakeCopy()C3_Obj.title = 'C!D3!N{' + self.title + '}'C3_Obj.mnemonic = 'C3'values = cohValues[*,3]C3_Obj.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)C3_Obj.vrange = [0, vmax];; set up output structure;result = { Name:'CoherenceScan', C1:C1_Obj, C2:C2_Obj, C3:C3_Obj }RETURN, resultEND ; ****** GKVs2D::CoherenceScan ****** ;