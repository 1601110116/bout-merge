Function GKVs1D::FluxInfo, phiObj, nRef=n_Ref, Tref=T_ref, c_s=c_s, rho_s=rho_s; ; Purpose:;;	GKVs1D::FluxInfo expects:;;		'self'	to contian the density vs. theta and t at fixed 'x'.;		'phi'	to contain the corresponding potential vs. theta and t at same fixed 'x'.;;  KeyWords:;;	nRef	"Reference" value of density (that is, constant needed to turn density signal;		to units of cm^-3).  Defaults to 1.0 (Optional);;	Tref	"Reference" value of the temperature (that is, constant needed to turn phi ;		signal to units of eV).  Defaults to 1.0 (Optional);;	c_s	Value of sound speed (in cm/s).  Defautls to 1.0, which means that the particle;		flux will be returned in arbitrary units.;;	rho_s	Value of sound radius (in cm).   Defautls to 1.0, which means that the particle;		flux will be returned in arbitrary units.;;;  OUTPUT:;;	FluxInfo returns an anonymous structure containging:;;		n_rms	The rms value of  dn;;		Phi_rms	The rms value of dPhi;;		Flux	The (theta-average) particle flux;;; Written by W.M. Neving;	11/07/02;FORWARD_FUNCTION GKVsd_MINnPtr = self -> GetValues()n = *nPtrPTR_FREE, nPtrnNorm = 1IF(N_ELEMENTS(n_Ref) EQ 1) THEN nNorm = n_Refinfo = SIZE(n)nDim = info[0]nPoints = FLOAT(info[nDim+2])avg_n = TOTAL(n)/nPointsavg_nSq = TOTAL(n^2)/nPointsn_rms = nNorm*SQRT(avg_nSq - avg_n^2)phiPtr = phiObj -> GetValues()phi = *phiPtrPTR_FREE, phiPtrphiNorm = 1IF(N_ELEMENTS(T_Ref) EQ 1) THEN phiNorm = T_Refinfo = SIZE(phi)nDim = info[0]nPoints = FLOAT(info[nDim+2])avg_phi = TOTAL(phi)/nPointsavg_phiSq = TOTAL(phi^2)/nPointsphi_rms = phiNorm*SQRT(avg_phiSq - avg_phi^2)dPhidTheta = phiObj -> dbyd('theta')FluxObj = self -> times(dPhidTheta)avgFlux = FluxObj -> avg('theta')avgFlux_1 = avgFlux -> avg('t')flux = avgFlux_1 -> GetValues()dPhidTheta -> trashFluxobj    -> trashavgFlux    -> trashavgFlux_1  -> trashIF(N_ELEMENTS(c_s)*N_ELEMENTS(rho_s) EQ 1) THEN flux = nNorm*flux*c_s*rho_sresult = {Name:'FluxInfo', n_rms:n_rms, phi_rms:phi_rms, flux:flux}RETURN, resultEND  ; ****** GKVs1D::FluxInfo ****** ;FUNCTION GKVs2D::FluxAnalysis, arg, phiObj=phi_Obj, objStr=objStr, ni0=ni0, _Extra=Extra;; Purpose:;;	Compute rms density, potential, and particle flux vs. specified independent variable;	GKVs2d::FluxAnalysis expects 'self' to contain the (perturbed) density signal vs.;	x, theta and t.  ;;; Input Arguments:;;		GKVs2D::FluxAnalysis will accept any legal axis identifier;		(that is, an integer between 1 and 3, or a valid;		axis mnemonic) as an argument.  If no argument is ;		provided, then GKVs2D::FluxAnalysis will expect the axis;		corresponding to the inhomogeneous coordinate to be;		identified by keywords (see below). (Optional);;;  Input Keywords:;;	   phiObj	A GKVs3D object containg the corresponding (perturbed) potential;;	   objStr	alternatively, BOTH the density and potential may be passes within;			an anonamaous structure containting the tags 'Ni' (for the density);			and 'phi' (for the potential) ;;	     nRef	"Reference" value of density (that is, constant needed to turn density signal;			to units of cm^-3).  Defaults to 1.0 (Optional);;	     Tref	"Reference" value of the temperature (that is, constant needed to turn phi ;			signal to units of eV).  Defaults to 1.0 (Optional);;	      c_s	Value of sound speed (in cm/s).  Defautls to 1.0, which means that the particle;			flux will be returned in arbitrary units.;;	    rho_s	Value of sound radius (in cm).   Defautls to 1.0, which means that the particle;			flux will be returned in arbitrary units.;;	      ni0	A GKVs1D object containing the average (equilibrium) density vs. the selected;			independent variable.  Should be in units of cm^-3.  It ni0 is provided, then;			GKVs2D::Fluxanalysis will compute diffusion coefficeint / convection velocity.;			(Optional);;	     Axis	If no argument is provided, then this keyword may be ;			used to identify the inhomogeneous coordinate. Set axis ;			equal to any legal axis identifier (see above).;			(optional);;	 mnemonic	Set the mnemonic of the selected axis equal to a two-element ;			array, [min, max], to both identify the selected independent ;			variable, and reset the signal window on this axis.;			This two-element array is interpreted as the desired RANGE in;			the independent variable (i.e., it is interpreted in the units;			of the corresponding independent variable), NOT the integer 'irange';			(that is, NOT as an integer index into the grid.values array).;			(optional);;	   irange	Set 'irange' to a two-element (integer) array to reset the signal;			window of the selected independent variable.  The value of irange;			is interpreted as an index into the grid.values array.  'irange';			defaults to the current signal window of 'self.;			(optional);;	    range	Set 'range' to a two-element (floating point) array to set the;			range in the independent variable.;			(optional);;	     skip	The sampling interval for the specified inhomogeneous independent;			variable.  Defaults to 1 (Optional).;;;   Output Structure Tags:;;	n_rms		A scan of the rms density perturbation vs. selected the independent;			variable.  ;;	phi_rms		A scan of the rms potential perturbation vs. the selected independent;			variable;;	flux		A scan of the particle flux vs. the selected independent variable;;	D		The particle diffusion coefficient vs. the selected independent variable;			(if ni0 is provided).;;	V_conv		The convection velocity vs the selected independent variable;			(if ni0 is provided).;; Written by W.M. Nevins;	11/07/02;;; Get info from command line:;niObj = selfIF(N_ELEMENTS(Phi_Obj) GT 0) THEN phiObj=phi_ObjIF(N_ELEMENTS(ObjStr)  GT 0) THEN BEGIN	niObj  = ObjStr.ni	phiObj = ObjStr.phiENDIF;; First find identifier for axis corresponding to ; the inhomogeneous independent variable;CASE N_PARAMS() OF	0	:	axis = niObj -> AxisIrange(     _Extra=extra)	1	:	axis = niObj -> AxisIrange(arg, _Extra=extra)	ELSE	:	BEGIN				MESSAGE, 'FluxAnalysis called with too many arguments', /INFORMATIONAL				RETURN, 0			ENDENDCASEIF(axis LT 0) THEN BEGIN	MESSAGE, 'No valid axis identifier', /INFORMATIONAL	RETURN, 0ENDIF;; Get number of dimensions;nDims = niObj -> NumDims();; Find (integer) sampling interval; skip = 1iskip = GetKeyWord('skip', extra)IF(TypeOf(iskip) NE 7) THEN skip = FIX(iskip) > 1;; Create GKV structure to hold result,; and copy fields from 'self' to 'result';result = {GKVs1D}						FOR i=0, N_TAGS(result) - 1 DO 	$	result.(i) = niObj.(i)	;; Get grid structure corresponding to ; the inhomogeneous independent variable;axisString = STRING(axis, FORMAT='(I1)')commandString = 'grid = niObj.Grid' + axisStringok = EXECUTE(commandString)IF NOT ok THEN BEGIN	MESSAGE, "Could not extract inhomogeneous Grid Structure:  ", /INFORMATIONAL	MESSAGE, "Command String = " + commandString, /INFORMATIONAL	RETURN, 0ENDIFIF(N_ELEMENTS(arg) EQ 0) THEN arg=Grid.mnemonic	oldGridValues = *Grid.values;;; Set up loop over inhomogeneous independent variable;gridTitle = Grid.titlegridMnemonic = Grid.mnemonicirange = Grid.irangeimax = irange[1]-irange[0] nPoints = (imax +1)/skipnewGridValues = FLTARR(nPoints)scanValues = FLTARR(nPoints, 4);; Begin loop over inhomogeneous independent variable;FOR i=0, nPoints-1 DO BEGIN						; 'i' is index into 'result' arrays, while 'index' is the  	index = irange[0]+i*skip					; index to the inhomogeneous independent variable of 'self'. 	newGridValues[i] = oldGridValues[index]				; 	Set new grid values	tempNiObj  = niObj  -> Slice(axis=axis, index=index)		;	Slice 'niObj' at current value of inhomogeneous variable			tempPhiObj = phiObj -> Slice(axis=axis, index=index)		;	Slice 'phiObj' as well	tempFluxStr = tempNiObj -> FluxInfo(tempPhiObj, _Extra=Extra)	;	Compute 'FluxInfo' at this location	FOR j=1,3 DO scanValues[i,j] = tempfluxStr.(j)			;	and store results in scanValues	tempNiObj   -> Trash						; Clean up	tempPhiObj  -> TrashENDFOR;; Set fields of output Grid structure;Grid.values = PTR_NEW(newGridValues)Grid.uniform = GKVsd_UniformGrid(newGridValues)IF( (Grid.irange[0] NE 0) OR (Grid.irange[1] NE (N_ELEMENTS(oldGridValues)-1)) ) THEN Grid.boundary = 'open'xmin = MIN(newGridValues, MAX=xmax)Grid.range  = [xmin,xmax]Grid.irange = [0,nPoints-1];; Set fields of 'result' structure (containing taucorr vs. inhomogeneous coordinate);axisMnemonic = Grid.mnemonicaxisTitle = Grid.titleresult.mnemonic = 'n_rms'result.title = '!4d!Xn!Drms!N'CASE axis OF								;	1:	indices = niObj -> IndexRemove([2,3])			; Remove 'indices' corresponding to	2:	indices = niObj -> IndexRemove([1,3])			; the homogeneous independent variables	3:	indices = niObj -> IndexRemove([1,2])			; ENDCASEresult.indices = PTR_NEW(indices)result.units = 'cm!U-3!N'values = scanValues[*,1]result.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)result.vrange = [0.0, vmax]result.ErrorBars = PTR_NEW()result.Grid1 = Grid;; register 'result' as a GKVs1D object;nirms_Obj = OBJ_NEW('GKVs1D', result);; Now make phi_rms object ;phirms_Obj = nirms_Obj -> MakeCopy()phirms_Obj.title = '!12<!4du!12>!X!Drms!N'phirms_Obj.mnemonic = 'phi_rms'phirms_Obj.units='V'values = scanValues[*,2]phirms_Obj.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)phirms_Obj.vrange = [0, vmax];; and flux object;flux_Obj = nirms_Obj -> MakeCopy()flux_Obj.title = '!12<!4C!12>!X'flux_Obj.mnemonic = 'Flux'flux_Obj.units = 'cm!U-2!N/s'values = scanValues[*,3]flux_Obj.values = PTR_NEW(values)vmin = GKVsd_MIN(values, Max=vmax)flux_Obj.vrange = [0, vmax];; set up output structure;result = { Name:'FluxAnalysis', n_rms:nirms_obj, phi_rms:phirms_obj, flux:flux_Obj };IF(N_ELEMENTS(ni0) GT 0) THEN BEGIN	dni0dx = ni0 -> dbyd(axis)	V_conv = Flux_Obj -> over(ni0, title='V!Dconv!N', mnemonic='V_conv', units='cm/s')	temp = dni0dx -> times(-1)	D = Flux_Obj -> over(temp, title='D!Dmidpland!N', mnemonic='D', units='cm!U2!N/s')	result = CREATE_STRUCT(result, 'D', D, 'V_conv', V_conv)	dni0dx -> trash	temp   -> trashENDIF;RETURN, resultEND ; ****** GKVs2D::FluxAnalysis ****** ;