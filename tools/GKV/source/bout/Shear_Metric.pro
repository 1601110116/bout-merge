FUNCTION CModData, jy=iy;; Data on C-Mod QC geometry via E-mail from:;	Sender: xu@popcorn.llnl.gov;	Date: Tue, 23 Jan 2001 14:20:28 -0800;	From: Xu Xueqiao <xxu@llnl.gov>;	Organization: LLNL;	X-Accept-Language: en;	To: "W.M. Nevins" <nevins1@llnl.gov>;	Subject: Re: magnetic shear and k_x ...;;	Hi, Bill:;;	    Here is the integral of magnetic shear from mid to jy=52. so radial;	mode number will be:;	;	kr = kx - sx_hat*kz.;	;	Here the sx_hat is given below.;;	Xu;; From which I conclude that the following coordinate transformation will ; produce a local orthogonal grid:;;	x' = x;	z' = z + º^x Sx_hat(x) dx; (from which it follows that;;		 ¶/¶x'|z' = ¶/¶x|z - Sx_hat ¶/¶z|x ;; as desired).;; Written by W.M. Nevins;  1/24/01;; FIrst use Xu's data to define Sx_hat and jy arrays;Sx_hat = FLTARR(4, 40)jy = INTARR(4)jy[0] = 41;jx, sx_hatSx_hat[0, 0:39] = [	$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0,			$0 ]			jy[1] = 47; jx, sx_hatSx_hat[1, 0:39] = [	$1.1496,			$1.16472,		$1.18476,		$1.22146,		$1.23036,		$1.23315,		$1.23938,		$1.25581,		$1.27907,		$1.29749,		$1.33511,		$1.36084,		$1.36053,		$1.37759,		$1.37988,		$1.37181,		$1.41187,		$1.4119,			$1.44646,		$1.50425,		$1.49278,		$1.49327,		$1.50099,		$1.50464,		$1.52021,		$1.53924,		$1.56248,		$1.58527,		$1.58641,		$1.56727,		$1.56967,		$1.5715,			$1.55931,		$1.58654,		$1.61727,		$1.60501,		$1.58028,		$1.56357,		$1.55488,		$1.56519 ]		jy[2] =50; jx, sx_hatSx_hat[2, 0:39] = [	$1.05124,		$1.05501,		$1.06104,		$1.08286,		$1.08423,		$1.08369,		$1.07974,		$1.08358,		$1.09892,		$1.0855,			$1.09094,		$1.12316,		$1.12382,		$1.10803,		$1.09744,		$1.10275,		$1.11216,		$1.07706,		$1.03874,		$1.15998,		$1.19269,		$1.10524,		$1.10143,		$1.10146,		$1.1055,			$1.10557,		$1.10656,		$1.10461,		$1.09326,		$1.08007,		$1.07276,		$1.04582,		$1.03134,		$1.04659,		$1.04947,		$1.01454,		$0.98637,		$0.984291,		$0.967683,		$0.954166 ]		jy[3] = 52; jx, sx_hatSx_hat[3, 0:39] = [	$1.78322,		$1.7433,			$1.72472,		$	1.73196,		$1.70718,		$1.64557,		$1.56625,		$1.47969,		$1.43094,		$1.39658,		$1.36873,		$1.31741,		$1.23633,		$1.15559,		$1.06234,		$0.965632,		$0.864501,		$0.721938,		$0.336356,		$0.813055,		$1.02836,		$0.4926,			$0.442611,		$0.361108,		$0.301315,		$0.243397,		$0.1827,			$0.126496,		$0.0656977,		$0.000932564,		$-0.0602416,		$-0.123176,		$-0.18091,		$-0.239103,		$-0.302672,		$-0.354002,		$-0.397192,		$-0.443668,		$-0.49022,		$-0.516196 ]		;; Now, try to find match between value of jy in command line and values supplied by Xu;result = -1FOR i=0, N_ELEMENTS(jy)-1 DO BEGIN	IF(iy EQ jy[i]) THEN result = Sx_hat[i,*]ENDFORRETURN, resultEND ; ****** CModData ****** ;PRO GKVs2D::ShearMetric, jy=iy, SxHat=Sx_hat, Back=back;; Correct BOUT data object for shear in magnetic  field;; Arguments:	None;	;; Keywords:;;	SxHat	Set to an array containing integral of magnetic shear from midplane;		to polodial location of present data slice.  Default is to use data;		from Xu's E-mail of 1/23/01 (see comments to CModData below).;		(optional);;	jy	If using data from Xu's E-mail of 1/23/01, set this keyword equal to;		the y-index of the poloidal location of this data slice.  Defaults;		to zero.;;	Back	Set this keyword (i.e., put "/Back" on the command line) to undo previous ;		shear correction in BOUT's coordinate system;;; Written by W.M. Nevins;	1/24/01;FORWARD_FUNCTION CModDatanDims = self -> NumDims();; Get SxHat;jy=0IF(N_ELEMENTS(Sx_hat) GT 0) THEN BEGIN	SxHat = Sx_hatENDIF ELSE BEGIN	IF(N_ELEMENTS(iy) EQ 1) THEN jy=iy	SxHat = CModData(jy=jy)ENDELSE;; Get x-axis values;xValues = *self.grid1.values;; perform integral Int(x) Sxhat	dx;xPoints = N_ELEMENTS(xValues)IF(N_ELEMENTS(SxHat) NE xPoints) THEN BEGIN	MESSAGE, "Bad SxHat data", /INFORMATIONAL	RETURNENDIFdx = xValues - SHIFT(xValues, 1)integrand = 0.5*( SxHat + SHIFT(SxHat, 1) )*dxintegrand[0] = 0.zShift = TOTAL(integrand, /CUMULATIVE);; Find x-index at separatrix;temp = xValues^2smallStuff = MIN(temp, iSeparatrix);; Inforce convention that we don't shift the separatrix;zShift = zShift - zShift[iSeparatrix] IF(N_ELEMENTS(back) EQ 1) THEN zShift = -zShift ;; Find z-axis identifier;zAxis = self -> AxisNumber("z")str_zAxis = STRING(zaxis, FORMAT ='(I1)') ;; Get grid structure for z-axis;commandStr = "zGrid = self.Grid" + str_zAxis ok = EXECUTE(commandStr)IF(zGrid.uniform NE 1b) THEN BEGIN	MESSAGE, "Non-uniform z-axis, returning", /INFORMATIONAL	RETURNENDIF;; Get array of z-values, # of grid points, etc.;zPoints = N_ELEMENTS(*zGrid.values)zValues = *zGrid.valuesdz = zValues[1] - zValues[0];; Get dependent variable values (without boundary points in the array!);oldInfo = SIZE(*self.values)CASE zGrid.boundary OF	"periodic (open)"	:	BEGIN						lz = zValues[zPoints-1] - zValues[0] + dz						values = *self.values					END	"peroidic (closed)"	:	BEGIN						zPoints = zPoints-1						zValues = zValues[0:(zPoints-1)]						lz = zValues[zPoints-1] - zValues[0] + dz						values = (*self.Values)[*,0:(zPoints-1)]					END	"periodic"		:	BEGIN						zPoints = zPoints-1						zValues = zValues[0:(zPoints-1)]						lz = zValues[zPoints-1] - zValues[0] + dz						values = (*self.Values)[*,0:(zPoints-1)]					END	ELSE			:	BEGIN						text = "Bad BC for z-grid, zGrid.boundary = "+zGrid.boundary						MESSAGE, text, /INFORMATIONAL						RETURN					ENDENDCASE;; Create array to hold shifted values;newInfo = SIZE(values)newValues = MAKE_ARRAY(SIZE=newInfo);; At each value of x, shift Values in z-index by the local value of zShift;izShift = FIX(zShift/dz)dzShift = zShift/dz - izShiftFOR i=0, xPoints-1 DO BEGIN	newValues[i,*] = (1-dzShift[i])*SHIFT(values[i,*], 0, izShift[i]) + dzShift[i]*SHIFT(values[i,*], 0, izShift[i]+1)ENDFOR;; Make pointer to result, adding boundary points if necessary;CASE zGrid.boundary OF	"periodic (open)"	:		valuePtr = PTR_NEW(newValues)	"peroidic (closed)"	:	BEGIN						values = MAKE_ARRAY(SIZE=oldInfo)						values[*,0:(zPoints-1)] = newValues						values[*,zPoints] = values[*,0]						valuePtr = PTR_NEW(values)					END	"periodic"		:	BEGIN						values = MAKE_ARRAY(SIZE=oldInfo)						values[*,0:(zPoints-1)] = newValues						values[*,zPoints] = values[*,0]						valuePtr = PTR_NEW(values)					END	ELSE			:	BEGIN						text = "Bad BC for z-grid, zGrid.boundary = "+zGrid.boundary						MESSAGE, text, /INFORMATIONAL						RETURN					ENDENDCASE;; Load new values into self;PTR_FREE, self.valuesself.values = ValuePtr;; Put jy value into "FileID" field;jyString = STRING(jy, FORMAT ='(I2)')self.FileID = "jy = " + jyString;; and we're done;RETURNEND ; ****** GKVs2D::Shear_Metric ****** ;PRO GKVs3D::ShearMetric, jy=iy, SxHat=Sx_hat, Back=back;; Correct BOUT data object for shear in magnetic  field;; Arguments:	None;	;; Keywords:;;	SxHat	Set to an array containing integral of magnetic shear from midplane;		to polodial location of present data slice.  Default is to use data;		from Xu's E-mail of 1/23/01 (see comments to CModData below).;		(optional);;	jy	If using data from Xu's E-mail of 1/23/01, set this keyword equal to;		the y-index of the poloidal location of this data slice.  Defaults;		to zero.;;	Back	Set this keyword (i.e., put "/Back" on the command line) to undo previous ;		shear correction in BOUT's coordinate system;;; Written by W.M. Nevins;	1/24/01;FORWARD_FUNCTION CModDatanDims = self -> NumDims();; Get SxHat;jy=0IF(N_ELEMENTS(Sx_hat) GT 0) THEN BEGIN	SxHat = Sx_hatENDIF ELSE BEGIN	IF(N_ELEMENTS(iy) EQ 1) THEN jy=iy	SxHat = CModData(jy=jy)ENDELSE;; Get x-axis values;xValues = *self.grid1.values;; perform integral Int(x) Sxhat	dx;xPoints = N_ELEMENTS(xValues)IF(N_ELEMENTS(SxHat) NE xPoints) THEN BEGIN	MESSAGE, "Bad SxHat data", /INFORMATIONAL	RETURNENDIFdx = xValues - SHIFT(xValues, 1)integrand = 0.5*( SxHat + SHIFT(SxHat, 1) )*dxintegrand[0] = 0.zShift = TOTAL(integrand, /CUMULATIVE);; Find x-index at separatrix;temp = xValues^2smallStuff = MIN(temp, iSeparatrix);; Inforce convention that we don't shift the separatrix;zShift = zShift - zShift[iSeparatrix]IF(N_ELEMENTS(back) EQ 1) THEN zShift = -zShift ;; Find z-axis identifier;zAxis = self -> AxisNumber("z")str_zAxis = STRING(zaxis, FORMAT ='(I1)') ;; Get grid structure for z-axis;commandStr = "zGrid = self.Grid" + str_zAxis ok = EXECUTE(commandStr)IF(zGrid.uniform NE 1b) THEN BEGIN	MESSAGE, "Non-uniform z-axis, returning", /INFORMATIONAL	RETURNENDIF;; Get array of z-values, # of grid points, etc.;zPoints = N_ELEMENTS(*zGrid.values)zValues = *zGrid.valuesdz = zValues[1] - zValues[0];; Get dependent variable values (without boundary points in the array!);oldInfo = SIZE(*self.values)CASE zGrid.boundary OF	"periodic (open)"	:	BEGIN						lz = zValues[zPoints-1] - zValues[0] + dz						values = *self.values					END	"peroidic (closed)"	:	BEGIN						zPoints = zPoints-1						zValues = zValues[0:(zPoints-1)]						lz = zValues[zPoints-1] - zValues[0] + dz						values = (*self.Values)[*,0:(zPoints-1),*]					END	"periodic"		:	BEGIN						zPoints = zPoints-1						zValues = zValues[0:(zPoints-1)]						lz = zValues[zPoints-1] - zValues[0] + dz						values = (*self.Values)[*,0:(zPoints-1),*]					END	ELSE			:	BEGIN						text = "Bad BC for z-grid, zGrid.boundary = "+zGrid.boundary						MESSAGE, text, /INFORMATIONAL						RETURN					ENDENDCASE;; Create array to hold shifted values;newInfo = SIZE(values)newValues = MAKE_ARRAY(SIZE=newInfo);; At each value of x, shift Values in z-index by the local value of zShift;izShift = FIX(zShift/dz)dzShift = zShift/dz - izShiftFOR i=0, xPoints-1 DO BEGIN	newValues[i,*,*] = (1-dzShift[i])*SHIFT(values[i,*,*], 0, izShift[i], 0) + dzShift[i]*SHIFT(values[i,*,*], 0, izShift[i]+1, 0)ENDFOR;; Make pointer to result, adding boundary points if necessary;CASE zGrid.boundary OF	"periodic (open)"	:		valuePtr = PTR_NEW(newValues)	"peroidic (closed)"	:	BEGIN						values = MAKE_ARRAY(SIZE=oldInfo)						values[*,0:(zPoints-1),*] = newValues						values[*,zPoints,*] = values[*,0,*]						valuePtr = PTR_NEW(values)					END	"periodic"		:	BEGIN						values = MAKE_ARRAY(SIZE=oldInfo)						values[*,0:(zPoints-1),*] = newValues						values[*,zPoints,*] = values[*,0,*]						valuePtr = PTR_NEW(values)					END	ELSE			:	BEGIN						text = "Bad BC for z-grid, zGrid.boundary = "+zGrid.boundary						MESSAGE, text, /INFORMATIONAL						RETURN					ENDENDCASE;; Load new values into self;PTR_FREE, self.valuesself.values = ValuePtr;; Put jy value into "FileID" field;jyString = STRING(jy, FORMAT ='(I2)')self.FileID = "jy = " + jyString;; and we're done;RETURNEND ; ****** GKVs3D::Shear_Metric ****** ;